# coding: utf-8

"""
    Basespace API

    Basespace REST API  # noqa: E501

    OpenAPI spec version: 5.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class BasespaceApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_v2_appsessions_id(self, id, **kwargs):  # noqa: E501
        """Delete a specific analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_appsessions_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str preserve: Preserve \"Metadata\", to keep records, but not files, of an appsession
        :param bool bypasstrash: Select true to go straight to deletion
        :return: V1pre3TrashItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_v2_appsessions_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_v2_appsessions_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_v2_appsessions_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a specific analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_appsessions_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str preserve: Preserve \"Metadata\", to keep records, but not files, of an appsession
        :param bool bypasstrash: Select true to go straight to deletion
        :return: V1pre3TrashItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'preserve', 'bypasstrash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_v2_appsessions_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_v2_appsessions_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'preserve' in params:
            query_params.append(('preserve', params['preserve']))  # noqa: E501
        if 'bypasstrash' in params:
            query_params.append(('bypasstrash', params['bypasstrash']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3TrashItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_v2_appsessions_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """Delete a property of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_appsessions_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str name: Property name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_v2_appsessions_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_v2_appsessions_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def delete_v2_appsessions_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """Delete a property of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_appsessions_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str name: Property name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_v2_appsessions_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_v2_appsessions_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_v2_appsessions_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/properties/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_v2_icauploads_foldertype_dataid(self, foldertype, dataid, **kwargs):  # noqa: E501
        """delete_v2_icauploads_foldertype_dataid  # noqa: E501

        Delete a resource in ICA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_icauploads_foldertype_dataid(foldertype, dataid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str foldertype: (required)
        :param str dataid: (required)
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_v2_icauploads_foldertype_dataid_with_http_info(foldertype, dataid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_v2_icauploads_foldertype_dataid_with_http_info(foldertype, dataid, **kwargs)  # noqa: E501
            return data

    def delete_v2_icauploads_foldertype_dataid_with_http_info(self, foldertype, dataid, **kwargs):  # noqa: E501
        """delete_v2_icauploads_foldertype_dataid  # noqa: E501

        Delete a resource in ICA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_icauploads_foldertype_dataid_with_http_info(foldertype, dataid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str foldertype: (required)
        :param str dataid: (required)
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['foldertype', 'dataid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_v2_icauploads_foldertype_dataid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'foldertype' is set
        if ('foldertype' not in params or
                params['foldertype'] is None):
            raise ValueError("Missing the required parameter `foldertype` when calling `delete_v2_icauploads_foldertype_dataid`")  # noqa: E501
        # verify the required parameter 'dataid' is set
        if ('dataid' not in params or
                params['dataid'] is None):
            raise ValueError("Missing the required parameter `dataid` when calling `delete_v2_icauploads_foldertype_dataid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'foldertype' in params:
            path_params['foldertype'] = params['foldertype']  # noqa: E501
        if 'dataid' in params:
            path_params['dataid'] = params['dataid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/icauploads/{foldertype}/{dataid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_v2_notifications_id(self, id, **kwargs):  # noqa: E501
        """delete_v2_notifications_id  # noqa: E501

        Delete a notification  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_notifications_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_v2_notifications_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_v2_notifications_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_v2_notifications_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_v2_notifications_id  # noqa: E501

        Delete a notification  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_notifications_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_v2_notifications_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_v2_notifications_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/notifications/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_v2_oauthv2tokens_current(self, **kwargs):  # noqa: E501
        """delete_v2_oauthv2tokens_current  # noqa: E501

        Invalidate/delete token for a given user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_oauthv2tokens_current(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_v2_oauthv2tokens_current_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_v2_oauthv2tokens_current_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_v2_oauthv2tokens_current_with_http_info(self, **kwargs):  # noqa: E501
        """delete_v2_oauthv2tokens_current  # noqa: E501

        Invalidate/delete token for a given user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_oauthv2tokens_current_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_v2_oauthv2tokens_current" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/oauthv2tokens/current', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_v2_session_invalidate(self, **kwargs):  # noqa: E501
        """Log out user from Sequence Hub and end session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_session_invalidate(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_v2_session_invalidate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_v2_session_invalidate_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_v2_session_invalidate_with_http_info(self, **kwargs):  # noqa: E501
        """Log out user from Sequence Hub and end session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_session_invalidate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_v2_session_invalidate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/session/invalidate', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_v2_trash(self, **kwargs):  # noqa: E501
        """Delete all items in the trash  # noqa: E501

        Deleting all items from the trash is a non-reversible action. All items and their files will be removed from Sequence Hub permanently.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_trash(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_v2_trash_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_v2_trash_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_v2_trash_with_http_info(self, **kwargs):  # noqa: E501
        """Delete all items in the trash  # noqa: E501

        Deleting all items from the trash is a non-reversible action. All items and their files will be removed from Sequence Hub permanently.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_v2_trash_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_v2_trash" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/trash', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_agreements_id(self, id, **kwargs):  # noqa: E501
        """Get detailed information about a single agreement  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_agreements_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Agreement ID (required)
        :return: V2Agreement
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_agreements_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_agreements_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_agreements_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get detailed information about a single agreement  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_agreements_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Agreement ID (required)
        :return: V2Agreement
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_agreements_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_agreements_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/agreements/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Agreement',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_applicationmetadata(self, **kwargs):  # noqa: E501
        """Request metadata about applications  # noqa: E501

        Request metadata about applications  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applicationmetadata(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource
        :return: ApplicationMetadataV2ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_applicationmetadata_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_applicationmetadata_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_applicationmetadata_with_http_info(self, **kwargs):  # noqa: E501
        """Request metadata about applications  # noqa: E501

        Request metadata about applications  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applicationmetadata_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource
        :return: ApplicationMetadataV2ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_applicationmetadata" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applicationmetadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationMetadataV2ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_applications(self, cwlactive, autolaunchableonruncompleteappsonly, allversions, **kwargs):  # noqa: E501
        """Get a list of available applications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications(cwlactive, autolaunchableonruncompleteappsonly, allversions, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool cwlactive: Deprecated as of May 2024. Has no effect, but left here for API backwards compatibility. (required)
        :param bool autolaunchableonruncompleteappsonly: Returns only applications that can be auto-launched after a run completes (required)
        :param bool allversions: Return all the applications versions (required)
        :param str category: Return all apps that belong to a specific category that a user has access to (examples include: Native, Workflow, Other). Only a single category can be specified in a given call
        :param str references: Returns all analysis workflows that a user has access to that were created from a particular app, denoted by its unique slug ID
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V1pre3ApplicationCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_applications_with_http_info(cwlactive, autolaunchableonruncompleteappsonly, allversions, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_applications_with_http_info(cwlactive, autolaunchableonruncompleteappsonly, allversions, **kwargs)  # noqa: E501
            return data

    def get_v2_applications_with_http_info(self, cwlactive, autolaunchableonruncompleteappsonly, allversions, **kwargs):  # noqa: E501
        """Get a list of available applications  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_with_http_info(cwlactive, autolaunchableonruncompleteappsonly, allversions, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool cwlactive: Deprecated as of May 2024. Has no effect, but left here for API backwards compatibility. (required)
        :param bool autolaunchableonruncompleteappsonly: Returns only applications that can be auto-launched after a run completes (required)
        :param bool allversions: Return all the applications versions (required)
        :param str category: Return all apps that belong to a specific category that a user has access to (examples include: Native, Workflow, Other). Only a single category can be specified in a given call
        :param str references: Returns all analysis workflows that a user has access to that were created from a particular app, denoted by its unique slug ID
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V1pre3ApplicationCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cwlactive', 'autolaunchableonruncompleteappsonly', 'allversions', 'category', 'references', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_applications" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cwlactive' is set
        if ('cwlactive' not in params or
                params['cwlactive'] is None):
            raise ValueError("Missing the required parameter `cwlactive` when calling `get_v2_applications`")  # noqa: E501
        # verify the required parameter 'autolaunchableonruncompleteappsonly' is set
        if ('autolaunchableonruncompleteappsonly' not in params or
                params['autolaunchableonruncompleteappsonly'] is None):
            raise ValueError("Missing the required parameter `autolaunchableonruncompleteappsonly` when calling `get_v2_applications`")  # noqa: E501
        # verify the required parameter 'allversions' is set
        if ('allversions' not in params or
                params['allversions'] is None):
            raise ValueError("Missing the required parameter `allversions` when calling `get_v2_applications`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'references' in params:
            query_params.append(('references', params['references']))  # noqa: E501
        if 'cwlactive' in params:
            query_params.append(('cwlactive', params['cwlactive']))  # noqa: E501
        if 'autolaunchableonruncompleteappsonly' in params:
            query_params.append(('autolaunchableonruncompleteappsonly', params['autolaunchableonruncompleteappsonly']))  # noqa: E501
        if 'allversions' in params:
            query_params.append(('allversions', params['allversions']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3ApplicationCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_applications_id(self, id, **kwargs):  # noqa: E501
        """Get information about an app  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Returns only the specified number of properties for the application.
        :param int propertyitemslimit: Returns only the specified number of property items per property for the application
        :return: V1pre3Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_applications_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_applications_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_applications_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about an app  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Returns only the specified number of properties for the application.
        :param int propertyitemslimit: Returns only the specified number of property items per property for the application
        :return: V1pre3Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_applications_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_applications_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_applications_id_qcthresholds(self, id, **kwargs):  # noqa: E501
        """Get a list of QC thresholds applied to an analysis workflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_qcthresholds(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2QcThresholdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_applications_id_qcthresholds_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_applications_id_qcthresholds_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_applications_id_qcthresholds_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of QC thresholds applied to an analysis workflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_qcthresholds_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2QcThresholdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_applications_id_qcthresholds" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_applications_id_qcthresholds`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}/qcthresholds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2QcThresholdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_applications_id_screenshots(self, id, **kwargs):  # noqa: E501
        """Get screenshots of an app  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_screenshots(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: ApplicationScreenshotsV2ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_applications_id_screenshots_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_applications_id_screenshots_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_applications_id_screenshots_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get screenshots of an app  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_screenshots_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: ApplicationScreenshotsV2ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_applications_id_screenshots" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_applications_id_screenshots`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}/screenshots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationScreenshotsV2ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_applications_id_settings(self, id, **kwargs):  # noqa: E501
        """Get the settings of an application or workflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_settings(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2ApplicationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_applications_id_settings_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_applications_id_settings_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_applications_id_settings_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the settings of an application or workflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_settings_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2ApplicationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_applications_id_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_applications_id_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2ApplicationSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_applications_id_versions(self, id, **kwargs):  # noqa: E501
        """Get versions of an app  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_versions(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V1pre3ApplicationCompactV1pre3ApplicationsSortFieldsV2ListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_applications_id_versions_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_applications_id_versions_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_applications_id_versions_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get versions of an app  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_versions_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V1pre3ApplicationCompactV1pre3ApplicationsSortFieldsV2ListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_applications_id_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_applications_id_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3ApplicationCompactV1pre3ApplicationsSortFieldsV2ListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_applications_id_workflowdependencies(self, id, **kwargs):  # noqa: E501
        """Get a list of workflow dependencies on an analysis workflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_workflowdependencies(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2AnalysisWorkflowDependenciesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_applications_id_workflowdependencies_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_applications_id_workflowdependencies_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_applications_id_workflowdependencies_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of workflow dependencies on an analysis workflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_applications_id_workflowdependencies_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2AnalysisWorkflowDependenciesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_applications_id_workflowdependencies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_applications_id_workflowdependencies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}/workflowdependencies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AnalysisWorkflowDependenciesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appresults_id_file_upload_info(self, id, **kwargs):  # noqa: E501
        """get_v2_appresults_id_file_upload_info  # noqa: E501

        Request direct file upload presigned url information for a new file in the specified resource (dataset or appresult)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appresults_id_file_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str filepath:
        :param int uploadpartcount:
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appresults_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appresults_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_appresults_id_file_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_appresults_id_file_upload_info  # noqa: E501

        Request direct file upload presigned url information for a new file in the specified resource (dataset or appresult)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appresults_id_file_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str filepath:
        :param int uploadpartcount:
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'filepath', 'uploadpartcount']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appresults_id_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appresults_id_file_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'filepath' in params:
            query_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'uploadpartcount' in params:
            query_params.append(('uploadpartcount', params['uploadpartcount']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appresults/{id}/file-upload-info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PresignedUrlForUpload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions(self, **kwargs):  # noqa: E501
        """Get a list of analyses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int appid: Filter by ID of application used
        :param list[str] applicationfamilyslugs: Filter by application family
        :param bool ownedbycurrentuser: Only include appsessions where the project has WRITE permission by the current user
        :param str datemodified:
        :param str executionstatus: Filter by execution status
        :param str qcstatus: Filter by QC status
        :param str deliverystatus: Filter by delivery status
        :param str name:
        :param list[int] output_projects: Filter by ID of output project
        :param list[int] input_runs: Filter by ID of run input
        :param list[int] input_biosamples: Filter by ID of biosample input
        :param list[str] include: Additional resources to include
        :param list[str] propertyfilters: Filter by appsessions include the specified property names
        :param int usercreatedby: ID of user who created appsession
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of analyses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int appid: Filter by ID of application used
        :param list[str] applicationfamilyslugs: Filter by application family
        :param bool ownedbycurrentuser: Only include appsessions where the project has WRITE permission by the current user
        :param str datemodified:
        :param str executionstatus: Filter by execution status
        :param str qcstatus: Filter by QC status
        :param str deliverystatus: Filter by delivery status
        :param str name:
        :param list[int] output_projects: Filter by ID of output project
        :param list[int] input_runs: Filter by ID of run input
        :param list[int] input_biosamples: Filter by ID of biosample input
        :param list[str] include: Additional resources to include
        :param list[str] propertyfilters: Filter by appsessions include the specified property names
        :param int usercreatedby: ID of user who created appsession
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['appid', 'applicationfamilyslugs', 'ownedbycurrentuser', 'datemodified', 'executionstatus', 'qcstatus', 'deliverystatus', 'name', 'output_projects', 'input_runs', 'input_biosamples', 'include', 'propertyfilters', 'usercreatedby', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'appid' in params:
            query_params.append(('appid', params['appid']))  # noqa: E501
        if 'applicationfamilyslugs' in params:
            query_params.append(('applicationfamilyslugs', params['applicationfamilyslugs']))  # noqa: E501
            collection_formats['applicationfamilyslugs'] = 'csv'  # noqa: E501
        if 'ownedbycurrentuser' in params:
            query_params.append(('ownedbycurrentuser', params['ownedbycurrentuser']))  # noqa: E501
        if 'datemodified' in params:
            query_params.append(('datemodified', params['datemodified']))  # noqa: E501
        if 'executionstatus' in params:
            query_params.append(('executionstatus', params['executionstatus']))  # noqa: E501
        if 'qcstatus' in params:
            query_params.append(('qcstatus', params['qcstatus']))  # noqa: E501
        if 'deliverystatus' in params:
            query_params.append(('deliverystatus', params['deliverystatus']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'output_projects' in params:
            query_params.append(('output.projects', params['output_projects']))  # noqa: E501
            collection_formats['output.projects'] = 'csv'  # noqa: E501
        if 'input_runs' in params:
            query_params.append(('input.runs', params['input_runs']))  # noqa: E501
            collection_formats['input.runs'] = 'csv'  # noqa: E501
        if 'input_biosamples' in params:
            query_params.append(('input.biosamples', params['input_biosamples']))  # noqa: E501
            collection_formats['input.biosamples'] = 'csv'  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'usercreatedby' in params:
            query_params.append(('usercreatedby', params['usercreatedby']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id(self, id, **kwargs):  # noqa: E501
        """Get information about an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param list[str] include: Additional resources to include
        :param str showhiddenitems: ShowHiddenItems 
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param list[str] include: Additional resources to include
        :param str showhiddenitems: ShowHiddenItems 
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_comments(self, id, **kwargs):  # noqa: E501
        """Get a list of comments made about an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_comments(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2CommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_comments_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_comments_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_comments_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of comments made about an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_comments_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2CommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_comments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2CommentList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs(self, id, **kwargs):  # noqa: E501
        """Get ICA log steps for workflows and analyses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaLogPathList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get ICA log steps for workflows and analyses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaLogPathList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaLogPathList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_analyses_analysisid_stepid(self, id, analysisid, stepid, **kwargs):  # noqa: E501
        """Get ICA analysis log step stdout stderr log paths  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid(id, analysisid, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str analysisid: ICA Analyses Id (required)
        :param str stepid: Step ID (required)
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaStepLogCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_with_http_info(id, analysisid, stepid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_with_http_info(id, analysisid, stepid, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_with_http_info(self, id, analysisid, stepid, **kwargs):  # noqa: E501
        """Get ICA analysis log step stdout stderr log paths  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_with_http_info(id, analysisid, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str analysisid: ICA Analyses Id (required)
        :param str stepid: Step ID (required)
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaStepLogCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'analysisid', 'stepid', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_analyses_analysisid_stepid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid`")  # noqa: E501
        # verify the required parameter 'analysisid' is set
        if ('analysisid' not in params or
                params['analysisid'] is None):
            raise ValueError("Missing the required parameter `analysisid` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid`")  # noqa: E501
        # verify the required parameter 'stepid' is set
        if ('stepid' not in params or
                params['stepid'] is None):
            raise ValueError("Missing the required parameter `stepid` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'analysisid' in params:
            path_params['analysisid'] = params['analysisid']  # noqa: E501
        if 'stepid' in params:
            path_params['stepid'] = params['stepid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/analyses/{analysisid}/{stepid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaStepLogCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr(self, id, analysisid, stepid, **kwargs):  # noqa: E501
        """Get ICA analysis step stderr log  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr(id, analysisid, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str analysisid: ICA Analyses Id (required)
        :param str stepid: Step ID (required)
        :return: V2AppSessionIcaStepLog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr_with_http_info(id, analysisid, stepid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr_with_http_info(id, analysisid, stepid, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr_with_http_info(self, id, analysisid, stepid, **kwargs):  # noqa: E501
        """Get ICA analysis step stderr log  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr_with_http_info(id, analysisid, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str analysisid: ICA Analyses Id (required)
        :param str stepid: Step ID (required)
        :return: V2AppSessionIcaStepLog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'analysisid', 'stepid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr`")  # noqa: E501
        # verify the required parameter 'analysisid' is set
        if ('analysisid' not in params or
                params['analysisid'] is None):
            raise ValueError("Missing the required parameter `analysisid` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr`")  # noqa: E501
        # verify the required parameter 'stepid' is set
        if ('stepid' not in params or
                params['stepid'] is None):
            raise ValueError("Missing the required parameter `stepid` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stderr`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'analysisid' in params:
            path_params['analysisid'] = params['analysisid']  # noqa: E501
        if 'stepid' in params:
            path_params['stepid'] = params['stepid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/analyses/{analysisid}/{stepid}/stderr', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaStepLog',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout(self, id, analysisid, stepid, **kwargs):  # noqa: E501
        """Get ICA analysis step stdout log  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout(id, analysisid, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str analysisid: ICA Analyses Id (required)
        :param str stepid: Step ID (required)
        :return: V2AppSessionIcaStepLog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout_with_http_info(id, analysisid, stepid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout_with_http_info(id, analysisid, stepid, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout_with_http_info(self, id, analysisid, stepid, **kwargs):  # noqa: E501
        """Get ICA analysis step stdout log  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout_with_http_info(id, analysisid, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str analysisid: ICA Analyses Id (required)
        :param str stepid: Step ID (required)
        :return: V2AppSessionIcaStepLog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'analysisid', 'stepid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout`")  # noqa: E501
        # verify the required parameter 'analysisid' is set
        if ('analysisid' not in params or
                params['analysisid'] is None):
            raise ValueError("Missing the required parameter `analysisid` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout`")  # noqa: E501
        # verify the required parameter 'stepid' is set
        if ('stepid' not in params or
                params['stepid'] is None):
            raise ValueError("Missing the required parameter `stepid` when calling `get_v2_appsessions_id_icalogs_analyses_analysisid_stepid_stdout`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'analysisid' in params:
            path_params['analysisid'] = params['analysisid']  # noqa: E501
        if 'stepid' in params:
            path_params['stepid'] = params['stepid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/analyses/{analysisid}/{stepid}/stdout', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaStepLog',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_analyses_icaanalysisid(self, id, icaanalysisid, includetechnicalsteps, **kwargs):  # noqa: E501
        """Get ICA analysis log steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_analyses_icaanalysisid(id, icaanalysisid, includetechnicalsteps, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str icaanalysisid: ICA Analyses Id (required)
        :param bool includetechnicalsteps: Include technical steps (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaStepLogCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_analyses_icaanalysisid_with_http_info(id, icaanalysisid, includetechnicalsteps, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_analyses_icaanalysisid_with_http_info(id, icaanalysisid, includetechnicalsteps, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_analyses_icaanalysisid_with_http_info(self, id, icaanalysisid, includetechnicalsteps, **kwargs):  # noqa: E501
        """Get ICA analysis log steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_analyses_icaanalysisid_with_http_info(id, icaanalysisid, includetechnicalsteps, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str icaanalysisid: ICA Analyses Id (required)
        :param bool includetechnicalsteps: Include technical steps (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaStepLogCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'icaanalysisid', 'includetechnicalsteps', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_analyses_icaanalysisid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_analyses_icaanalysisid`")  # noqa: E501
        # verify the required parameter 'icaanalysisid' is set
        if ('icaanalysisid' not in params or
                params['icaanalysisid'] is None):
            raise ValueError("Missing the required parameter `icaanalysisid` when calling `get_v2_appsessions_id_icalogs_analyses_icaanalysisid`")  # noqa: E501
        # verify the required parameter 'includetechnicalsteps' is set
        if ('includetechnicalsteps' not in params or
                params['includetechnicalsteps'] is None):
            raise ValueError("Missing the required parameter `includetechnicalsteps` when calling `get_v2_appsessions_id_icalogs_analyses_icaanalysisid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'icaanalysisid' in params:
            path_params['icaanalysisid'] = params['icaanalysisid']  # noqa: E501

        query_params = []
        if 'includetechnicalsteps' in params:
            query_params.append(('includetechnicalsteps', params['includetechnicalsteps']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/analyses/{icaanalysisid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaStepLogCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_orchestrated_analyses(self, id, **kwargs):  # noqa: E501
        """Get orchestrated analyses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_orchestrated_analyses(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaLogPathList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_orchestrated_analyses_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_orchestrated_analyses_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_orchestrated_analyses_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get orchestrated analyses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_orchestrated_analyses_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaLogPathList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_orchestrated_analyses" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_orchestrated_analyses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/orchestrated-analyses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaLogPathList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_workflowsession(self, id, includetechnicalsteps, **kwargs):  # noqa: E501
        """Get ICA workflow session log steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_workflowsession(id, includetechnicalsteps, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param bool includetechnicalsteps: Include technical steps (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaStepLogCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_workflowsession_with_http_info(id, includetechnicalsteps, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_workflowsession_with_http_info(id, includetechnicalsteps, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_workflowsession_with_http_info(self, id, includetechnicalsteps, **kwargs):  # noqa: E501
        """Get ICA workflow session log steps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_workflowsession_with_http_info(id, includetechnicalsteps, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param bool includetechnicalsteps: Include technical steps (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaStepLogCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'includetechnicalsteps', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_workflowsession" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_workflowsession`")  # noqa: E501
        # verify the required parameter 'includetechnicalsteps' is set
        if ('includetechnicalsteps' not in params or
                params['includetechnicalsteps'] is None):
            raise ValueError("Missing the required parameter `includetechnicalsteps` when calling `get_v2_appsessions_id_icalogs_workflowsession`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'includetechnicalsteps' in params:
            query_params.append(('includetechnicalsteps', params['includetechnicalsteps']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/workflowsession', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaStepLogCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_workflowsession_stepid(self, id, stepid, **kwargs):  # noqa: E501
        """Get ICA workflow session log step stdout stderr log paths  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_workflowsession_stepid(id, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str stepid: Step ID (required)
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaStepLogCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_workflowsession_stepid_with_http_info(id, stepid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_workflowsession_stepid_with_http_info(id, stepid, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_workflowsession_stepid_with_http_info(self, id, stepid, **kwargs):  # noqa: E501
        """Get ICA workflow session log step stdout stderr log paths  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_workflowsession_stepid_with_http_info(id, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str stepid: Step ID (required)
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2AppSessionIcaStepLogCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'stepid', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_workflowsession_stepid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_workflowsession_stepid`")  # noqa: E501
        # verify the required parameter 'stepid' is set
        if ('stepid' not in params or
                params['stepid'] is None):
            raise ValueError("Missing the required parameter `stepid` when calling `get_v2_appsessions_id_icalogs_workflowsession_stepid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'stepid' in params:
            path_params['stepid'] = params['stepid']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/workflowsession/{stepid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaStepLogCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr(self, id, stepid, **kwargs):  # noqa: E501
        """Get ICA workflow session log step stderr  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr(id, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str stepid: Step ID (required)
        :return: V2AppSessionIcaStepLog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr_with_http_info(id, stepid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr_with_http_info(id, stepid, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr_with_http_info(self, id, stepid, **kwargs):  # noqa: E501
        """Get ICA workflow session log step stderr  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr_with_http_info(id, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str stepid: Step ID (required)
        :return: V2AppSessionIcaStepLog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'stepid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr`")  # noqa: E501
        # verify the required parameter 'stepid' is set
        if ('stepid' not in params or
                params['stepid'] is None):
            raise ValueError("Missing the required parameter `stepid` when calling `get_v2_appsessions_id_icalogs_workflowsession_stepid_stderr`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'stepid' in params:
            path_params['stepid'] = params['stepid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/workflowsession/{stepid}/stderr', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaStepLog',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout(self, id, stepid, **kwargs):  # noqa: E501
        """Get ICA workflow session log step stdout  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout(id, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str stepid: Step ID (required)
        :return: V2AppSessionIcaStepLog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout_with_http_info(id, stepid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout_with_http_info(id, stepid, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout_with_http_info(self, id, stepid, **kwargs):  # noqa: E501
        """Get ICA workflow session log step stdout  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout_with_http_info(id, stepid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str stepid: Step ID (required)
        :return: V2AppSessionIcaStepLog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'stepid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout`")  # noqa: E501
        # verify the required parameter 'stepid' is set
        if ('stepid' not in params or
                params['stepid'] is None):
            raise ValueError("Missing the required parameter `stepid` when calling `get_v2_appsessions_id_icalogs_workflowsession_stepid_stdout`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'stepid' in params:
            path_params['stepid'] = params['stepid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/icalogs/workflowsession/{stepid}/stdout', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSessionIcaStepLog',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_logfiles(self, id, excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, **kwargs):  # noqa: E501
        """Get a list of logs of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_logfiles(id, excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param bool excludevcfindexfolder: Whether to exclude VCF index folders (required)
        :param bool excludebamcoveragefolder: Whether to exclude BAM coverage folders (required)
        :param bool excludesystemfolder: Whether to exclude system folders (required)
        :param bool excludeemptyfiles: Whether to exclude empty files (required)
        :param bool filehrefcontentresolution: Resolves the HrefContent to the direct file URI to avoid a hop to GET: files/{id}/content (required)
        :param bool turbomode: (required)
        :param str filesetid:
        :param str extensions: Filter by file extension
        :param str excludeextensions: Exclude by file extension
        :param str directory: Filter by directory path (root is /)
        :param bool includesubdirectories: Whether to return subdirectories
        :param list[str] statuses: Optionally filter by status (default complete)
        :param str pathprefix: To be pre-fixed in the path of the file
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_logfiles_with_http_info(id, excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_logfiles_with_http_info(id, excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_logfiles_with_http_info(self, id, excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, **kwargs):  # noqa: E501
        """Get a list of logs of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_logfiles_with_http_info(id, excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param bool excludevcfindexfolder: Whether to exclude VCF index folders (required)
        :param bool excludebamcoveragefolder: Whether to exclude BAM coverage folders (required)
        :param bool excludesystemfolder: Whether to exclude system folders (required)
        :param bool excludeemptyfiles: Whether to exclude empty files (required)
        :param bool filehrefcontentresolution: Resolves the HrefContent to the direct file URI to avoid a hop to GET: files/{id}/content (required)
        :param bool turbomode: (required)
        :param str filesetid:
        :param str extensions: Filter by file extension
        :param str excludeextensions: Exclude by file extension
        :param str directory: Filter by directory path (root is /)
        :param bool includesubdirectories: Whether to return subdirectories
        :param list[str] statuses: Optionally filter by status (default complete)
        :param str pathprefix: To be pre-fixed in the path of the file
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'excludevcfindexfolder', 'excludebamcoveragefolder', 'excludesystemfolder', 'excludeemptyfiles', 'filehrefcontentresolution', 'turbomode', 'filesetid', 'extensions', 'excludeextensions', 'directory', 'includesubdirectories', 'statuses', 'pathprefix', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_logfiles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_logfiles`")  # noqa: E501
        # verify the required parameter 'excludevcfindexfolder' is set
        if ('excludevcfindexfolder' not in params or
                params['excludevcfindexfolder'] is None):
            raise ValueError("Missing the required parameter `excludevcfindexfolder` when calling `get_v2_appsessions_id_logfiles`")  # noqa: E501
        # verify the required parameter 'excludebamcoveragefolder' is set
        if ('excludebamcoveragefolder' not in params or
                params['excludebamcoveragefolder'] is None):
            raise ValueError("Missing the required parameter `excludebamcoveragefolder` when calling `get_v2_appsessions_id_logfiles`")  # noqa: E501
        # verify the required parameter 'excludesystemfolder' is set
        if ('excludesystemfolder' not in params or
                params['excludesystemfolder'] is None):
            raise ValueError("Missing the required parameter `excludesystemfolder` when calling `get_v2_appsessions_id_logfiles`")  # noqa: E501
        # verify the required parameter 'excludeemptyfiles' is set
        if ('excludeemptyfiles' not in params or
                params['excludeemptyfiles'] is None):
            raise ValueError("Missing the required parameter `excludeemptyfiles` when calling `get_v2_appsessions_id_logfiles`")  # noqa: E501
        # verify the required parameter 'filehrefcontentresolution' is set
        if ('filehrefcontentresolution' not in params or
                params['filehrefcontentresolution'] is None):
            raise ValueError("Missing the required parameter `filehrefcontentresolution` when calling `get_v2_appsessions_id_logfiles`")  # noqa: E501
        # verify the required parameter 'turbomode' is set
        if ('turbomode' not in params or
                params['turbomode'] is None):
            raise ValueError("Missing the required parameter `turbomode` when calling `get_v2_appsessions_id_logfiles`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'filesetid' in params:
            query_params.append(('filesetid', params['filesetid']))  # noqa: E501
        if 'extensions' in params:
            query_params.append(('extensions', params['extensions']))  # noqa: E501
        if 'excludeextensions' in params:
            query_params.append(('excludeextensions', params['excludeextensions']))  # noqa: E501
        if 'directory' in params:
            query_params.append(('directory', params['directory']))  # noqa: E501
        if 'includesubdirectories' in params:
            query_params.append(('includesubdirectories', params['includesubdirectories']))  # noqa: E501
        if 'excludevcfindexfolder' in params:
            query_params.append(('excludevcfindexfolder', params['excludevcfindexfolder']))  # noqa: E501
        if 'excludebamcoveragefolder' in params:
            query_params.append(('excludebamcoveragefolder', params['excludebamcoveragefolder']))  # noqa: E501
        if 'excludesystemfolder' in params:
            query_params.append(('excludesystemfolder', params['excludesystemfolder']))  # noqa: E501
        if 'excludeemptyfiles' in params:
            query_params.append(('excludeemptyfiles', params['excludeemptyfiles']))  # noqa: E501
        if 'filehrefcontentresolution' in params:
            query_params.append(('filehrefcontentresolution', params['filehrefcontentresolution']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501
        if 'turbomode' in params:
            query_params.append(('turbomode', params['turbomode']))  # noqa: E501
        if 'pathprefix' in params:
            query_params.append(('pathprefix', params['pathprefix']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/logfiles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2FilesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_properties(self, id, **kwargs):  # noqa: E501
        """Get a list of properties of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of properties of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """Get information about a property of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """Get information about a property of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_appsessions_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_properties_name_items(self, id, name, **kwargs):  # noqa: E501
        """Get a list of items from a property of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_properties_name_items(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_properties_name_items_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """Get a list of items from a property of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_properties_name_items_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_properties_name_items`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_appsessions_id_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_appsessions_id_reports(self, id, **kwargs):  # noqa: E501
        """get_v2_appsessions_id_reports  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_reports(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_appsessions_id_reports_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_appsessions_id_reports_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_appsessions_id_reports_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_appsessions_id_reports  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_appsessions_id_reports_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_appsessions_id_reports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_appsessions_id_reports`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/reports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_archivingstats(self, **kwargs):  # noqa: E501
        """Get a summary of total archiving Data Managment Events , their status  .  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_archivingstats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str eventaction:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_archivingstats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_archivingstats_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_archivingstats_with_http_info(self, **kwargs):  # noqa: E501
        """Get a summary of total archiving Data Managment Events , their status  .  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_archivingstats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str eventaction:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['eventaction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_archivingstats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'eventaction' in params:
            query_params.append(('eventaction', params['eventaction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/archivingstats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_archivingstatsdetails(self, **kwargs):  # noqa: E501
        """Get list of archiving Data Managment Events , their status  .  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_archivingstatsdetails(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_archivingstatsdetails_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_archivingstatsdetails_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_archivingstatsdetails_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of archiving Data Managment Events , their status  .  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_archivingstatsdetails_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_archivingstatsdetails" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/archivingstatsdetails', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_autodeletionevents(self, **kwargs):  # noqa: E501
        """Get a list of all auto-deletion events.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_autodeletionevents(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_autodeletionevents_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_autodeletionevents_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_autodeletionevents_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all auto-deletion events.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_autodeletionevents_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_autodeletionevents" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/autodeletionevents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_autodeletionpipeline(self, format, **kwargs):  # noqa: E501
        """Get the list of users who have entered the auto-deletion pipeline due to inactivity or exceeding their storage limit.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_autodeletionpipeline(format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format: (required)
        :param str emailtemplatename:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_autodeletionpipeline_with_http_info(format, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_autodeletionpipeline_with_http_info(format, **kwargs)  # noqa: E501
            return data

    def get_v2_autodeletionpipeline_with_http_info(self, format, **kwargs):  # noqa: E501
        """Get the list of users who have entered the auto-deletion pipeline due to inactivity or exceeding their storage limit.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_autodeletionpipeline_with_http_info(format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format: (required)
        :param str emailtemplatename:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'emailtemplatename']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_autodeletionpipeline" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_v2_autodeletionpipeline`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'emailtemplatename' in params:
            query_params.append(('emailtemplatename', params['emailtemplatename']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/autodeletionpipeline', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_autodeletionusers(self, sent, illuminausers, **kwargs):  # noqa: E501
        """Get a summary of users who are about to have their account data deleted due to data retention policy.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_autodeletionusers(sent, illuminausers, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool sent: (required)
        :param bool illuminausers: (required)
        :param str emailtemplatename:
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_autodeletionusers_with_http_info(sent, illuminausers, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_autodeletionusers_with_http_info(sent, illuminausers, **kwargs)  # noqa: E501
            return data

    def get_v2_autodeletionusers_with_http_info(self, sent, illuminausers, **kwargs):  # noqa: E501
        """Get a summary of users who are about to have their account data deleted due to data retention policy.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_autodeletionusers_with_http_info(sent, illuminausers, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool sent: (required)
        :param bool illuminausers: (required)
        :param str emailtemplatename:
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sent', 'illuminausers', 'emailtemplatename', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_autodeletionusers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sent' is set
        if ('sent' not in params or
                params['sent'] is None):
            raise ValueError("Missing the required parameter `sent` when calling `get_v2_autodeletionusers`")  # noqa: E501
        # verify the required parameter 'illuminausers' is set
        if ('illuminausers' not in params or
                params['illuminausers'] is None):
            raise ValueError("Missing the required parameter `illuminausers` when calling `get_v2_autodeletionusers`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'emailtemplatename' in params:
            query_params.append(('emailtemplatename', params['emailtemplatename']))  # noqa: E501
        if 'sent' in params:
            query_params.append(('sent', params['sent']))  # noqa: E501
        if 'illuminausers' in params:
            query_params.append(('illuminausers', params['illuminausers']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/autodeletionusers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples(self, **kwargs):  # noqa: E501
        """Get a list of biosamples  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] biosamplename: Only return biosamples with the given BioSampleName(s)
        :param list[str] include: Sub elements to include in the response
        :param list[str] propertynamestartswith:
        :param list[str] status: Only return biosamples with the given Status(es)
        :param list[str] labstatus: Only return biosamples with the given LabStatus(es)
        :param list[str] projectid: Only return biosamples with the specified default projects or datasets in those projects
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2BiologicalSampleCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of biosamples  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] biosamplename: Only return biosamples with the given BioSampleName(s)
        :param list[str] include: Sub elements to include in the response
        :param list[str] propertynamestartswith:
        :param list[str] status: Only return biosamples with the given Status(es)
        :param list[str] labstatus: Only return biosamples with the given LabStatus(es)
        :param list[str] projectid: Only return biosamples with the specified default projects or datasets in those projects
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2BiologicalSampleCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['biosamplename', 'include', 'propertynamestartswith', 'status', 'labstatus', 'projectid', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'biosamplename' in params:
            query_params.append(('biosamplename', params['biosamplename']))  # noqa: E501
            collection_formats['biosamplename'] = 'csv'  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'propertynamestartswith' in params:
            query_params.append(('propertynamestartswith', params['propertynamestartswith']))  # noqa: E501
            collection_formats['propertynamestartswith'] = 'csv'  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'labstatus' in params:
            query_params.append(('labstatus', params['labstatus']))  # noqa: E501
            collection_formats['labstatus'] = 'csv'  # noqa: E501
        if 'projectid' in params:
            query_params.append(('projectid', params['projectid']))  # noqa: E501
            collection_formats['projectid'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2BiologicalSampleCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples_biosampleid_labrequeues(self, biosampleid, **kwargs):  # noqa: E501
        """Get a list of a biosamples lab requeues  # noqa: E501

        All lab requeues, from each of the types, are listed here. A pool lab requeue will show up on the list of lab requeues for all biosamples that make up the pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_biosampleid_labrequeues(biosampleid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str biosampleid: Biosample ID (required)
        :param str type: Specify which type of lab requeue to be listed e.g. NewBioSampleLibrary, AdditionalYieldOfLibraryPool, or AdditionalYieldOfFinishedLibrary.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2LabRequeueCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_biosampleid_labrequeues_with_http_info(biosampleid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_biosampleid_labrequeues_with_http_info(biosampleid, **kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_biosampleid_labrequeues_with_http_info(self, biosampleid, **kwargs):  # noqa: E501
        """Get a list of a biosamples lab requeues  # noqa: E501

        All lab requeues, from each of the types, are listed here. A pool lab requeue will show up on the list of lab requeues for all biosamples that make up the pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_biosampleid_labrequeues_with_http_info(biosampleid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str biosampleid: Biosample ID (required)
        :param str type: Specify which type of lab requeue to be listed e.g. NewBioSampleLibrary, AdditionalYieldOfLibraryPool, or AdditionalYieldOfFinishedLibrary.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2LabRequeueCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['biosampleid', 'type', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples_biosampleid_labrequeues" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'biosampleid' is set
        if ('biosampleid' not in params or
                params['biosampleid'] is None):
            raise ValueError("Missing the required parameter `biosampleid` when calling `get_v2_biosamples_biosampleid_labrequeues`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'biosampleid' in params:
            path_params['biosampleid'] = params['biosampleid']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{biosampleid}/labrequeues', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LabRequeueCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples_id(self, id, **kwargs):  # noqa: E501
        """Get information about a biosample  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param list[str] include: Sub elements to include in the response
        :return: V2BiologicalSample
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a biosample  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param list[str] include: Sub elements to include in the response
        :return: V2BiologicalSample
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_biosamples_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2BiologicalSample',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples_id_aggregatedfastqdatasets(self, id, mixlibrarytypesallowed, **kwargs):  # noqa: E501
        """Get aggregated datasets for a given biosample  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_aggregatedfastqdatasets(id, mixlibrarytypesallowed, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param bool mixlibrarytypesallowed: If true, mixing datasets of different library types is allowed, false otherwise (required)
        :param list[str] selectedlibraryprepids: Optional comma-separated list of selected LibraryPrepId values to consider
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_id_aggregatedfastqdatasets_with_http_info(id, mixlibrarytypesallowed, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_id_aggregatedfastqdatasets_with_http_info(id, mixlibrarytypesallowed, **kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_id_aggregatedfastqdatasets_with_http_info(self, id, mixlibrarytypesallowed, **kwargs):  # noqa: E501
        """Get aggregated datasets for a given biosample  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_aggregatedfastqdatasets_with_http_info(id, mixlibrarytypesallowed, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param bool mixlibrarytypesallowed: If true, mixing datasets of different library types is allowed, false otherwise (required)
        :param list[str] selectedlibraryprepids: Optional comma-separated list of selected LibraryPrepId values to consider
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'mixlibrarytypesallowed', 'selectedlibraryprepids', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples_id_aggregatedfastqdatasets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_biosamples_id_aggregatedfastqdatasets`")  # noqa: E501
        # verify the required parameter 'mixlibrarytypesallowed' is set
        if ('mixlibrarytypesallowed' not in params or
                params['mixlibrarytypesallowed'] is None):
            raise ValueError("Missing the required parameter `mixlibrarytypesallowed` when calling `get_v2_biosamples_id_aggregatedfastqdatasets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'selectedlibraryprepids' in params:
            query_params.append(('selectedlibraryprepids', params['selectedlibraryprepids']))  # noqa: E501
            collection_formats['selectedlibraryprepids'] = 'csv'  # noqa: E501
        if 'mixlibrarytypesallowed' in params:
            query_params.append(('mixlibrarytypesallowed', params['mixlibrarytypesallowed']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}/aggregatedfastqdatasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples_id_libraries(self, id, **kwargs):  # noqa: E501
        """Get a list of a biosamples libraries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_libraries(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param list[str] include: Sub elements to include in the response: LibraryIndex, YieldInformation
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2LibraryCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_id_libraries_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_id_libraries_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_id_libraries_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of a biosamples libraries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_libraries_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param list[str] include: Sub elements to include in the response: LibraryIndex, YieldInformation
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2LibraryCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples_id_libraries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_biosamples_id_libraries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}/libraries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LibraryCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples_id_properties(self, id, **kwargs):  # noqa: E501
        """get_v2_biosamples_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_biosamples_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_biosamples_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """get_v2_biosamples_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_biosamples_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_biosamples_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_biosamples_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples_id_properties_name_items(self, id, name, **kwargs):  # noqa: E501
        """get_v2_biosamples_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_properties_name_items(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_id_properties_name_items_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_biosamples_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_properties_name_items_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples_id_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_biosamples_id_properties_name_items`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_biosamples_id_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_biosamples_id_runlanesummaries(self, id, **kwargs):  # noqa: E501
        """Get information about biosamples lane mapping  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_runlanesummaries(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2RunLaneSummaryList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_biosamples_id_runlanesummaries_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_biosamples_id_runlanesummaries_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_biosamples_id_runlanesummaries_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about biosamples lane mapping  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_biosamples_id_runlanesummaries_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2RunLaneSummaryList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_biosamples_id_runlanesummaries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_biosamples_id_runlanesummaries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}/runlanesummaries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2RunLaneSummaryList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets(self, **kwargs):  # noqa: E501
        """Get a list of datasets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] include: Can specify to return Properties, which returns an additional properties section for each dataset. Or return AppSessionRoot, which returns information about the root analysis of a workflow in the AppSession section for each dataset it applies to.
        :param list[str] propertyfilters: Specify which properties to include in the properties section, e.g. Input.BioSamples, Input.Libraries, or Input.Runs.
        :param list[str] datasettypes: Return datasets of this type or excluding this type. Supports comma-separated lists.
        :param list[str] qcstatus: Return datasets of this QC status.
        :param list[str] uploadstatus: Return datasets of this file upload status.
        :param list[int] inputbiosamples: Return datasets related to this biosample ID.
        :param list[int] inputruns: Return datasets related to this run ID.
        :param list[str] inputruntokens: Return datasets related to this run ID token.
        :param str projectid: Return datasets related to this project ID.
        :param list[int] appsessionids: Return datasets related to this app session ID.
        :param str isarchived: The archive states to filter by. Valid values include: True, False.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2DatasetCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_datasets_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of datasets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] include: Can specify to return Properties, which returns an additional properties section for each dataset. Or return AppSessionRoot, which returns information about the root analysis of a workflow in the AppSession section for each dataset it applies to.
        :param list[str] propertyfilters: Specify which properties to include in the properties section, e.g. Input.BioSamples, Input.Libraries, or Input.Runs.
        :param list[str] datasettypes: Return datasets of this type or excluding this type. Supports comma-separated lists.
        :param list[str] qcstatus: Return datasets of this QC status.
        :param list[str] uploadstatus: Return datasets of this file upload status.
        :param list[int] inputbiosamples: Return datasets related to this biosample ID.
        :param list[int] inputruns: Return datasets related to this run ID.
        :param list[str] inputruntokens: Return datasets related to this run ID token.
        :param str projectid: Return datasets related to this project ID.
        :param list[int] appsessionids: Return datasets related to this app session ID.
        :param str isarchived: The archive states to filter by. Valid values include: True, False.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2DatasetCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include', 'propertyfilters', 'datasettypes', 'qcstatus', 'uploadstatus', 'inputbiosamples', 'inputruns', 'inputruntokens', 'projectid', 'appsessionids', 'isarchived', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'datasettypes' in params:
            query_params.append(('datasettypes', params['datasettypes']))  # noqa: E501
            collection_formats['datasettypes'] = 'csv'  # noqa: E501
        if 'qcstatus' in params:
            query_params.append(('qcstatus', params['qcstatus']))  # noqa: E501
            collection_formats['qcstatus'] = 'csv'  # noqa: E501
        if 'uploadstatus' in params:
            query_params.append(('uploadstatus', params['uploadstatus']))  # noqa: E501
            collection_formats['uploadstatus'] = 'csv'  # noqa: E501
        if 'inputbiosamples' in params:
            query_params.append(('inputbiosamples', params['inputbiosamples']))  # noqa: E501
            collection_formats['inputbiosamples'] = 'csv'  # noqa: E501
        if 'inputruns' in params:
            query_params.append(('inputruns', params['inputruns']))  # noqa: E501
            collection_formats['inputruns'] = 'csv'  # noqa: E501
        if 'inputruntokens' in params:
            query_params.append(('inputruntokens', params['inputruntokens']))  # noqa: E501
            collection_formats['inputruntokens'] = 'csv'  # noqa: E501
        if 'projectid' in params:
            query_params.append(('projectid', params['projectid']))  # noqa: E501
        if 'appsessionids' in params:
            query_params.append(('appsessionids', params['appsessionids']))  # noqa: E501
            collection_formats['appsessionids'] = 'csv'  # noqa: E501
        if 'isarchived' in params:
            query_params.append(('isarchived', params['isarchived']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2DatasetCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets_id(self, id, **kwargs):  # noqa: E501
        """Get information about a dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dataset ID (required)
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_datasets_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dataset ID (required)
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasets_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets_id_comments(self, id, **kwargs):  # noqa: E501
        """Get a list of comments made about a dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_comments(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dataset ID (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2CommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_id_comments_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_id_comments_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_datasets_id_comments_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of comments made about a dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_comments_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dataset ID (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2CommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets_id_comments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasets_id_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2CommentList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets_id_direct_upload_info(self, id, **kwargs):  # noqa: E501
        """get_v2_datasets_id_direct_upload_info  # noqa: E501

        Request direct upload information for a new dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_direct_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V1pre3DirectUploadInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_id_direct_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_id_direct_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_datasets_id_direct_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_datasets_id_direct_upload_info  # noqa: E501

        Request direct upload information for a new dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_direct_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V1pre3DirectUploadInformation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets_id_direct_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasets_id_direct_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/direct-upload-info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3DirectUploadInformation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets_id_file_upload_info(self, id, **kwargs):  # noqa: E501
        """get_v2_datasets_id_file_upload_info  # noqa: E501

        Request direct file upload presigned url information for a new file in the specified resource (dataset or appresult)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_file_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str filepath:
        :param int uploadpartcount:
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_datasets_id_file_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_datasets_id_file_upload_info  # noqa: E501

        Request direct file upload presigned url information for a new file in the specified resource (dataset or appresult)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_file_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str filepath:
        :param int uploadpartcount:
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'filepath', 'uploadpartcount']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets_id_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasets_id_file_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'filepath' in params:
            query_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'uploadpartcount' in params:
            query_params.append(('uploadpartcount', params['uploadpartcount']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/file-upload-info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PresignedUrlForUpload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets_id_files(self, excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, id, **kwargs):  # noqa: E501
        """Get a list of files of a dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_files(excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool excludevcfindexfolder: Whether to exclude VCF index folders (required)
        :param bool excludebamcoveragefolder: Whether to exclude BAM coverage folders (required)
        :param bool excludesystemfolder: Whether to exclude system folders (required)
        :param bool excludeemptyfiles: Whether to exclude empty files (required)
        :param bool filehrefcontentresolution: Resolves the HrefContent to the direct file URI to avoid a hop to GET: files/{id}/content (required)
        :param bool turbomode: (required)
        :param str id: The Id of the resource (required)
        :param str filesetid:
        :param str extensions: Filter by file extension
        :param str excludeextensions: Exclude by file extension
        :param str directory: Filter by directory path (root is /)
        :param bool includesubdirectories: Whether to return subdirectories
        :param list[str] statuses: Optionally filter by status (default complete)
        :param str pathprefix: To be pre-fixed in the path of the file
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_id_files_with_http_info(excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_id_files_with_http_info(excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, id, **kwargs)  # noqa: E501
            return data

    def get_v2_datasets_id_files_with_http_info(self, excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, id, **kwargs):  # noqa: E501
        """Get a list of files of a dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_files_with_http_info(excludevcfindexfolder, excludebamcoveragefolder, excludesystemfolder, excludeemptyfiles, filehrefcontentresolution, turbomode, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool excludevcfindexfolder: Whether to exclude VCF index folders (required)
        :param bool excludebamcoveragefolder: Whether to exclude BAM coverage folders (required)
        :param bool excludesystemfolder: Whether to exclude system folders (required)
        :param bool excludeemptyfiles: Whether to exclude empty files (required)
        :param bool filehrefcontentresolution: Resolves the HrefContent to the direct file URI to avoid a hop to GET: files/{id}/content (required)
        :param bool turbomode: (required)
        :param str id: The Id of the resource (required)
        :param str filesetid:
        :param str extensions: Filter by file extension
        :param str excludeextensions: Exclude by file extension
        :param str directory: Filter by directory path (root is /)
        :param bool includesubdirectories: Whether to return subdirectories
        :param list[str] statuses: Optionally filter by status (default complete)
        :param str pathprefix: To be pre-fixed in the path of the file
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['excludevcfindexfolder', 'excludebamcoveragefolder', 'excludesystemfolder', 'excludeemptyfiles', 'filehrefcontentresolution', 'turbomode', 'id', 'filesetid', 'extensions', 'excludeextensions', 'directory', 'includesubdirectories', 'statuses', 'pathprefix', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets_id_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'excludevcfindexfolder' is set
        if ('excludevcfindexfolder' not in params or
                params['excludevcfindexfolder'] is None):
            raise ValueError("Missing the required parameter `excludevcfindexfolder` when calling `get_v2_datasets_id_files`")  # noqa: E501
        # verify the required parameter 'excludebamcoveragefolder' is set
        if ('excludebamcoveragefolder' not in params or
                params['excludebamcoveragefolder'] is None):
            raise ValueError("Missing the required parameter `excludebamcoveragefolder` when calling `get_v2_datasets_id_files`")  # noqa: E501
        # verify the required parameter 'excludesystemfolder' is set
        if ('excludesystemfolder' not in params or
                params['excludesystemfolder'] is None):
            raise ValueError("Missing the required parameter `excludesystemfolder` when calling `get_v2_datasets_id_files`")  # noqa: E501
        # verify the required parameter 'excludeemptyfiles' is set
        if ('excludeemptyfiles' not in params or
                params['excludeemptyfiles'] is None):
            raise ValueError("Missing the required parameter `excludeemptyfiles` when calling `get_v2_datasets_id_files`")  # noqa: E501
        # verify the required parameter 'filehrefcontentresolution' is set
        if ('filehrefcontentresolution' not in params or
                params['filehrefcontentresolution'] is None):
            raise ValueError("Missing the required parameter `filehrefcontentresolution` when calling `get_v2_datasets_id_files`")  # noqa: E501
        # verify the required parameter 'turbomode' is set
        if ('turbomode' not in params or
                params['turbomode'] is None):
            raise ValueError("Missing the required parameter `turbomode` when calling `get_v2_datasets_id_files`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasets_id_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'filesetid' in params:
            query_params.append(('filesetid', params['filesetid']))  # noqa: E501
        if 'extensions' in params:
            query_params.append(('extensions', params['extensions']))  # noqa: E501
        if 'excludeextensions' in params:
            query_params.append(('excludeextensions', params['excludeextensions']))  # noqa: E501
        if 'directory' in params:
            query_params.append(('directory', params['directory']))  # noqa: E501
        if 'includesubdirectories' in params:
            query_params.append(('includesubdirectories', params['includesubdirectories']))  # noqa: E501
        if 'excludevcfindexfolder' in params:
            query_params.append(('excludevcfindexfolder', params['excludevcfindexfolder']))  # noqa: E501
        if 'excludebamcoveragefolder' in params:
            query_params.append(('excludebamcoveragefolder', params['excludebamcoveragefolder']))  # noqa: E501
        if 'excludesystemfolder' in params:
            query_params.append(('excludesystemfolder', params['excludesystemfolder']))  # noqa: E501
        if 'excludeemptyfiles' in params:
            query_params.append(('excludeemptyfiles', params['excludeemptyfiles']))  # noqa: E501
        if 'filehrefcontentresolution' in params:
            query_params.append(('filehrefcontentresolution', params['filehrefcontentresolution']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501
        if 'turbomode' in params:
            query_params.append(('turbomode', params['turbomode']))  # noqa: E501
        if 'pathprefix' in params:
            query_params.append(('pathprefix', params['pathprefix']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2FilesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets_id_properties(self, id, **kwargs):  # noqa: E501
        """get_v2_datasets_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_datasets_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_datasets_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasets_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """get_v2_datasets_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_datasets_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_datasets_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasets_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_datasets_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasets_id_properties_name_items(self, id, name, **kwargs):  # noqa: E501
        """get_v2_datasets_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_properties_name_items(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasets_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasets_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_datasets_id_properties_name_items_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_datasets_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasets_id_properties_name_items_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasets_id_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasets_id_properties_name_items`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_datasets_id_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_datasettypes_id(self, id, **kwargs):  # noqa: E501
        """Get information about a dataset type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasettypes_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dataset type ID (required)
        :param list[str] include:
        :return: V2DatasetType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_datasettypes_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_datasettypes_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_datasettypes_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a dataset type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_datasettypes_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dataset type ID (required)
        :param list[str] include:
        :return: V2DatasetType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_datasettypes_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_datasettypes_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasettypes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2DatasetType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_gdssharetransferstats(self, **kwargs):  # noqa: E501
        """Get a summary of GDS share or transfer operations.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_gdssharetransferstats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str operationtype:
        :param str status:
        :param str maxitems:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_gdssharetransferstats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_gdssharetransferstats_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_gdssharetransferstats_with_http_info(self, **kwargs):  # noqa: E501
        """Get a summary of GDS share or transfer operations.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_gdssharetransferstats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str operationtype:
        :param str status:
        :param str maxitems:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['operationtype', 'status', 'maxitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_gdssharetransferstats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'operationtype' in params:
            query_params.append(('operationtype', params['operationtype']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'maxitems' in params:
            query_params.append(('maxitems', params['maxitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/gdssharetransferstats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_instrumentconnectioncheck_file_upload_info(self, **kwargs):  # noqa: E501
        """get_v2_instrumentconnectioncheck_file_upload_info  # noqa: E501

        Request access to temporary data presigned URL for upload to test connectivity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instrumentconnectioncheck_file_upload_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filepath:
        :param int uploadpartcount:
        :param str id: The Id of the resource
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_instrumentconnectioncheck_file_upload_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_instrumentconnectioncheck_file_upload_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_instrumentconnectioncheck_file_upload_info_with_http_info(self, **kwargs):  # noqa: E501
        """get_v2_instrumentconnectioncheck_file_upload_info  # noqa: E501

        Request access to temporary data presigned URL for upload to test connectivity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instrumentconnectioncheck_file_upload_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filepath:
        :param int uploadpartcount:
        :param str id: The Id of the resource
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filepath', 'uploadpartcount', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_instrumentconnectioncheck_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filepath' in params:
            query_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'uploadpartcount' in params:
            query_params.append(('uploadpartcount', params['uploadpartcount']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/instrumentconnectioncheck/file-upload-info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PresignedUrlForUpload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_instrumentdiagnostics_id(self, id, **kwargs):  # noqa: E501
        """get_v2_instrumentdiagnostics_id  # noqa: E501

        Get non-run instrument diagnostic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instrumentdiagnostics_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2InstrumentDiagnostic
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_instrumentdiagnostics_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_instrumentdiagnostics_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_instrumentdiagnostics_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_instrumentdiagnostics_id  # noqa: E501

        Get non-run instrument diagnostic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instrumentdiagnostics_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2InstrumentDiagnostic
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_instrumentdiagnostics_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_instrumentdiagnostics_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/instrumentdiagnostics/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2InstrumentDiagnostic',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_instruments(self, allworkgroups, activeruns, **kwargs):  # noqa: E501
        """get_v2_instruments  # noqa: E501

        List available instruments for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instruments(allworkgroups, activeruns, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool allworkgroups: (required)
        :param bool activeruns: (required)
        :param str fromdate:
        :param str todate:
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2InstrumentCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_instruments_with_http_info(allworkgroups, activeruns, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_instruments_with_http_info(allworkgroups, activeruns, **kwargs)  # noqa: E501
            return data

    def get_v2_instruments_with_http_info(self, allworkgroups, activeruns, **kwargs):  # noqa: E501
        """get_v2_instruments  # noqa: E501

        List available instruments for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instruments_with_http_info(allworkgroups, activeruns, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool allworkgroups: (required)
        :param bool activeruns: (required)
        :param str fromdate:
        :param str todate:
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2InstrumentCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['allworkgroups', 'activeruns', 'fromdate', 'todate', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_instruments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'allworkgroups' is set
        if ('allworkgroups' not in params or
                params['allworkgroups'] is None):
            raise ValueError("Missing the required parameter `allworkgroups` when calling `get_v2_instruments`")  # noqa: E501
        # verify the required parameter 'activeruns' is set
        if ('activeruns' not in params or
                params['activeruns'] is None):
            raise ValueError("Missing the required parameter `activeruns` when calling `get_v2_instruments`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'allworkgroups' in params:
            query_params.append(('allworkgroups', params['allworkgroups']))  # noqa: E501
        if 'activeruns' in params:
            query_params.append(('activeruns', params['activeruns']))  # noqa: E501
        if 'fromdate' in params:
            query_params.append(('fromdate', params['fromdate']))  # noqa: E501
        if 'todate' in params:
            query_params.append(('todate', params['todate']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/instruments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2InstrumentCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_instrumentstatistics(self, serialnumbers, fromdate, timezone, **kwargs):  # noqa: E501
        """Get instrument statistics  # noqa: E501

        Get instrument statistics for given serial numbers and time range. Returned data can be grouped by month or week.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instrumentstatistics(serialnumbers, fromdate, timezone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str serialnumbers: Comma-separated list of serial numbers. (required)
        :param object fromdate: From date in user ISO 8601 format. (required)
        :param str timezone: User timezone for binning. (required)
        :param object todate: To date in ISO 8601 format. Defaults to current date if not specified.
        :param str binby: BinBy can be 'week' or 'month'.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2InstrumentStatList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_instrumentstatistics_with_http_info(serialnumbers, fromdate, timezone, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_instrumentstatistics_with_http_info(serialnumbers, fromdate, timezone, **kwargs)  # noqa: E501
            return data

    def get_v2_instrumentstatistics_with_http_info(self, serialnumbers, fromdate, timezone, **kwargs):  # noqa: E501
        """Get instrument statistics  # noqa: E501

        Get instrument statistics for given serial numbers and time range. Returned data can be grouped by month or week.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instrumentstatistics_with_http_info(serialnumbers, fromdate, timezone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str serialnumbers: Comma-separated list of serial numbers. (required)
        :param object fromdate: From date in user ISO 8601 format. (required)
        :param str timezone: User timezone for binning. (required)
        :param object todate: To date in ISO 8601 format. Defaults to current date if not specified.
        :param str binby: BinBy can be 'week' or 'month'.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2InstrumentStatList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['serialnumbers', 'fromdate', 'timezone', 'todate', 'binby', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_instrumentstatistics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'serialnumbers' is set
        if ('serialnumbers' not in params or
                params['serialnumbers'] is None):
            raise ValueError("Missing the required parameter `serialnumbers` when calling `get_v2_instrumentstatistics`")  # noqa: E501
        # verify the required parameter 'fromdate' is set
        if ('fromdate' not in params or
                params['fromdate'] is None):
            raise ValueError("Missing the required parameter `fromdate` when calling `get_v2_instrumentstatistics`")  # noqa: E501
        # verify the required parameter 'timezone' is set
        if ('timezone' not in params or
                params['timezone'] is None):
            raise ValueError("Missing the required parameter `timezone` when calling `get_v2_instrumentstatistics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'serialnumbers' in params:
            path_params['serialnumbers'] = params['serialnumbers']  # noqa: E501
        if 'fromdate' in params:
            path_params['fromdate'] = params['fromdate']  # noqa: E501
        if 'timezone' in params:
            path_params['timezone'] = params['timezone']  # noqa: E501

        query_params = []
        if 'todate' in params:
            query_params.append(('todate', params['todate']))  # noqa: E501
        if 'binby' in params:
            query_params.append(('binby', params['binby']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/instrumentstatistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2InstrumentStatList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_instrumentstatus(self, includeactiveruns, **kwargs):  # noqa: E501
        """get_v2_instrumentstatus  # noqa: E501

        List of instruments with active runs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instrumentstatus(includeactiveruns, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool includeactiveruns: Set to true to include a list of active runs for each instrument.  Default is false. (required)
        :param str serialnumbers: A comma-delimited list of instrument serial numbers.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2InstrumentStatusCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_instrumentstatus_with_http_info(includeactiveruns, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_instrumentstatus_with_http_info(includeactiveruns, **kwargs)  # noqa: E501
            return data

    def get_v2_instrumentstatus_with_http_info(self, includeactiveruns, **kwargs):  # noqa: E501
        """get_v2_instrumentstatus  # noqa: E501

        List of instruments with active runs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_instrumentstatus_with_http_info(includeactiveruns, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool includeactiveruns: Set to true to include a list of active runs for each instrument.  Default is false. (required)
        :param str serialnumbers: A comma-delimited list of instrument serial numbers.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2InstrumentStatusCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['includeactiveruns', 'serialnumbers', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_instrumentstatus" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'includeactiveruns' is set
        if ('includeactiveruns' not in params or
                params['includeactiveruns'] is None):
            raise ValueError("Missing the required parameter `includeactiveruns` when calling `get_v2_instrumentstatus`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'serialnumbers' in params:
            query_params.append(('serialnumbers', params['serialnumbers']))  # noqa: E501
        if 'includeactiveruns' in params:
            query_params.append(('includeactiveruns', params['includeactiveruns']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/instrumentstatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2InstrumentStatusCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_labrequeues(self, **kwargs):  # noqa: E501
        """Get a list of lab requeues  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_labrequeues(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] status: Only return labrequeues with the given Status(es)
        :param list[str] type: Only return labrequeues with the given LabRequeueTypes(s)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2LabRequeueList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_labrequeues_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_labrequeues_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_labrequeues_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of lab requeues  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_labrequeues_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] status: Only return labrequeues with the given Status(es)
        :param list[str] type: Only return labrequeues with the given LabRequeueTypes(s)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2LabRequeueList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['status', 'type', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_labrequeues" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
            collection_formats['type'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/labrequeues', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LabRequeueList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_labrequeues_id(self, id, **kwargs):  # noqa: E501
        """Get information about a specific labrequeue  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_labrequeues_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Labrequeue ID (required)
        :return: V2LabRequeue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_labrequeues_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_labrequeues_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_labrequeues_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a specific labrequeue  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_labrequeues_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Labrequeue ID (required)
        :return: V2LabRequeue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_labrequeues_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_labrequeues_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/labrequeues/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LabRequeue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_laneqcthresholds(self, **kwargs):  # noqa: E501
        """Get a list of QC thresholds applied to lanes  # noqa: E501

        The QC thresholds are applied to a user's account. Any runs uploaded in that user's context will automatically have all lanes of the flowcell undergo automatic QC based on the QC thresholds. Thresholds are saved either to a lane, or to a lane and read number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_laneqcthresholds(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource
        :return: V2QcThresholdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_laneqcthresholds_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_laneqcthresholds_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_laneqcthresholds_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of QC thresholds applied to lanes  # noqa: E501

        The QC thresholds are applied to a user's account. Any runs uploaded in that user's context will automatically have all lanes of the flowcell undergo automatic QC based on the QC thresholds. Thresholds are saved either to a lane, or to a lane and read number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_laneqcthresholds_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource
        :return: V2QcThresholdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_laneqcthresholds" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/laneqcthresholds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2QcThresholdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_lanes_id(self, id, **kwargs):  # noqa: E501
        """Get information about a lane  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_lanes_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: Lane
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_lanes_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_lanes_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_lanes_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a lane  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_lanes_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: Lane
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_lanes_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_lanes_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/lanes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lane',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_lanes_id_comments(self, id, **kwargs):  # noqa: E501
        """Get a list of comments on a lane  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_lanes_id_comments(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Lane ID (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2CommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_lanes_id_comments_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_lanes_id_comments_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_lanes_id_comments_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of comments on a lane  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_lanes_id_comments_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Lane ID (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2CommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_lanes_id_comments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_lanes_id_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/lanes/{id}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2CommentList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_libraries(self, **kwargs):  # noqa: E501
        """Get a list of libraries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_libraries(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] status:
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2LibraryCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_libraries_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_libraries_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_libraries_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of libraries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_libraries_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] status:
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2LibraryCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['status', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_libraries" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/libraries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LibraryCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_libraries_id_properties(self, id, **kwargs):  # noqa: E501
        """get_v2_libraries_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_libraries_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_libraries_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_libraries_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_libraries_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_libraries_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_libraries_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_libraries_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_libraries_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/libraries/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_libraries_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """get_v2_libraries_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_libraries_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_libraries_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_libraries_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_libraries_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_libraries_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_libraries_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_libraries_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_libraries_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_libraries_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/libraries/{id}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_libraries_id_properties_name_items(self, id, name, **kwargs):  # noqa: E501
        """get_v2_libraries_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_libraries_id_properties_name_items(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_libraries_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_libraries_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_libraries_id_properties_name_items_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_libraries_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_libraries_id_properties_name_items_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_libraries_id_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_libraries_id_properties_name_items`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_libraries_id_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/libraries/{id}/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_librarypools(self, **kwargs):  # noqa: E501
        """Get a list of library pools  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] status: Possible values are: Active, Failed, Consumed, QCFailed
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V1pre3LibraryPoolCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_librarypools_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_librarypools_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_librarypools_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of library pools  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] status: Possible values are: Active, Failed, Consumed, QCFailed
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V1pre3LibraryPoolCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['status', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_librarypools" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/librarypools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3LibraryPoolCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_librarypools_id_libraries(self, id, **kwargs):  # noqa: E501
        """Get a list of libraries of a pool  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_id_libraries(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param list[str] include: Sub elements to include in the response: LibraryIndex, YieldInformation
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2LibraryCompactExtendedV2LibrarySortFieldsResourceList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_librarypools_id_libraries_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_librarypools_id_libraries_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_librarypools_id_libraries_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of libraries of a pool  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_id_libraries_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param list[str] include: Sub elements to include in the response: LibraryIndex, YieldInformation
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2LibraryCompactExtendedV2LibrarySortFieldsResourceList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_librarypools_id_libraries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_librarypools_id_libraries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/librarypools/{id}/libraries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LibraryCompactExtendedV2LibrarySortFieldsResourceList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_librarypools_id_properties(self, id, **kwargs):  # noqa: E501
        """get_v2_librarypools_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_librarypools_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_librarypools_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_librarypools_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_librarypools_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_librarypools_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_librarypools_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/librarypools/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_librarypools_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """get_v2_librarypools_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_librarypools_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_librarypools_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_librarypools_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_librarypools_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_librarypools_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_librarypools_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_librarypools_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/librarypools/{id}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_librarypools_id_properties_name_items(self, id, name, **kwargs):  # noqa: E501
        """get_v2_librarypools_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_id_properties_name_items(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_librarypools_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_librarypools_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_librarypools_id_properties_name_items_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_librarypools_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_librarypools_id_properties_name_items_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_librarypools_id_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_librarypools_id_properties_name_items`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_librarypools_id_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/librarypools/{id}/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_projects_id(self, id, **kwargs):  # noqa: E501
        """Get information about a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param int propertieslimit:
        :param int propertyitemslimit:
        :param list[str] include:
        :return: V1pre3Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_projects_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_projects_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_projects_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param int propertieslimit:
        :param int propertyitemslimit:
        :param list[str] include:
        :return: V1pre3Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_projects_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_projects_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_projects_id_datasets(self, id, **kwargs):  # noqa: E501
        """Get a list of datasets in a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_datasets(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Project ID (required)
        :param str isarchived: The archive states to filter by. Valid values include: True, False.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2DatasetCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_projects_id_datasets_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_projects_id_datasets_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_projects_id_datasets_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of datasets in a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_datasets_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Project ID (required)
        :param str isarchived: The archive states to filter by. Valid values include: True, False.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2DatasetCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'isarchived', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_projects_id_datasets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_projects_id_datasets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'isarchived' in params:
            query_params.append(('isarchived', params['isarchived']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2DatasetCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_projects_id_properties(self, id, **kwargs):  # noqa: E501
        """get_v2_projects_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_projects_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_projects_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_projects_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_projects_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_projects_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_projects_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_projects_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """get_v2_projects_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_projects_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_projects_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_projects_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_projects_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_projects_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_projects_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_projects_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_projects_id_properties_name_items(self, id, name, **kwargs):  # noqa: E501
        """get_v2_projects_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_properties_name_items(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_projects_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_projects_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_projects_id_properties_name_items_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_projects_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_projects_id_properties_name_items_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_projects_id_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_projects_id_properties_name_items`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_projects_id_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_resourcemanifest(self, fileszipped, excludeemptyfiles, **kwargs):  # noqa: E501
        """Get a manifest of filesets for the requested resources (max 300 items)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_resourcemanifest(fileszipped, excludeemptyfiles, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool fileszipped: (required)
        :param bool excludeemptyfiles: (required)
        :param list[str] projects:
        :param list[str] appsessions:
        :param list[str] samples:
        :param list[str] appresults:
        :param list[str] datasets:
        :param list[str] runmetrics:
        :param list[str] runlogs:
        :param list[str] runimages:
        :param list[str] ipdrunparameters:
        :param list[str] extensions:
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2ResourceManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_resourcemanifest_with_http_info(fileszipped, excludeemptyfiles, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_resourcemanifest_with_http_info(fileszipped, excludeemptyfiles, **kwargs)  # noqa: E501
            return data

    def get_v2_resourcemanifest_with_http_info(self, fileszipped, excludeemptyfiles, **kwargs):  # noqa: E501
        """Get a manifest of filesets for the requested resources (max 300 items)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_resourcemanifest_with_http_info(fileszipped, excludeemptyfiles, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool fileszipped: (required)
        :param bool excludeemptyfiles: (required)
        :param list[str] projects:
        :param list[str] appsessions:
        :param list[str] samples:
        :param list[str] appresults:
        :param list[str] datasets:
        :param list[str] runmetrics:
        :param list[str] runlogs:
        :param list[str] runimages:
        :param list[str] ipdrunparameters:
        :param list[str] extensions:
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2ResourceManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fileszipped', 'excludeemptyfiles', 'projects', 'appsessions', 'samples', 'appresults', 'datasets', 'runmetrics', 'runlogs', 'runimages', 'ipdrunparameters', 'extensions', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_resourcemanifest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'fileszipped' is set
        if ('fileszipped' not in params or
                params['fileszipped'] is None):
            raise ValueError("Missing the required parameter `fileszipped` when calling `get_v2_resourcemanifest`")  # noqa: E501
        # verify the required parameter 'excludeemptyfiles' is set
        if ('excludeemptyfiles' not in params or
                params['excludeemptyfiles'] is None):
            raise ValueError("Missing the required parameter `excludeemptyfiles` when calling `get_v2_resourcemanifest`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'projects' in params:
            query_params.append(('projects', params['projects']))  # noqa: E501
            collection_formats['projects'] = 'csv'  # noqa: E501
        if 'appsessions' in params:
            query_params.append(('appsessions', params['appsessions']))  # noqa: E501
            collection_formats['appsessions'] = 'csv'  # noqa: E501
        if 'samples' in params:
            query_params.append(('samples', params['samples']))  # noqa: E501
            collection_formats['samples'] = 'csv'  # noqa: E501
        if 'appresults' in params:
            query_params.append(('appresults', params['appresults']))  # noqa: E501
            collection_formats['appresults'] = 'csv'  # noqa: E501
        if 'datasets' in params:
            query_params.append(('datasets', params['datasets']))  # noqa: E501
            collection_formats['datasets'] = 'csv'  # noqa: E501
        if 'runmetrics' in params:
            query_params.append(('runmetrics', params['runmetrics']))  # noqa: E501
            collection_formats['runmetrics'] = 'csv'  # noqa: E501
        if 'runlogs' in params:
            query_params.append(('runlogs', params['runlogs']))  # noqa: E501
            collection_formats['runlogs'] = 'csv'  # noqa: E501
        if 'runimages' in params:
            query_params.append(('runimages', params['runimages']))  # noqa: E501
            collection_formats['runimages'] = 'csv'  # noqa: E501
        if 'ipdrunparameters' in params:
            query_params.append(('ipdrunparameters', params['ipdrunparameters']))  # noqa: E501
            collection_formats['ipdrunparameters'] = 'csv'  # noqa: E501
        if 'fileszipped' in params:
            query_params.append(('fileszipped', params['fileszipped']))  # noqa: E501
        if 'extensions' in params:
            query_params.append(('extensions', params['extensions']))  # noqa: E501
            collection_formats['extensions'] = 'csv'  # noqa: E501
        if 'excludeemptyfiles' in params:
            query_params.append(('excludeemptyfiles', params['excludeemptyfiles']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/resourcemanifest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2ResourceManifest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs(self, **kwargs):  # noqa: E501
        """Get a list of runs accessible by current user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str statuses: The run statuses to filter by. Valid values include: New, Ready, Running, Paused, Stopped, Uploading, PendingAnalysis, Analyzing, Complete, Failed, NeedsAttention. Multiple values may be provided separated by commas.
        :param str instrumenttype: The instrument type to filter by.
        :param str laneandqcstatuses: The lane and QC statues to filter by.  Valid values include: Inital, QcPassed, and LaneQcFailed.  Multiple values may be separated by commas.
        :param str flowcellbarcode: The flowcell barcode to filter by. To request empty barcodes, provide an empty string
        :param str experimentname: The experiment name to filter by.
        :param list[int] output_projects: The project ids to filter by.
        :param list[str] include: Sub elements to include in the response
        :param list[str] propertynamestartswith: Filter properties by name starting with. Max items returned is 1024.
        :param list[str] excludepropertynamestartswith: Filter properties by name not starting with. Max items returned is 1024.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2RunCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_runs_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of runs accessible by current user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str statuses: The run statuses to filter by. Valid values include: New, Ready, Running, Paused, Stopped, Uploading, PendingAnalysis, Analyzing, Complete, Failed, NeedsAttention. Multiple values may be provided separated by commas.
        :param str instrumenttype: The instrument type to filter by.
        :param str laneandqcstatuses: The lane and QC statues to filter by.  Valid values include: Inital, QcPassed, and LaneQcFailed.  Multiple values may be separated by commas.
        :param str flowcellbarcode: The flowcell barcode to filter by. To request empty barcodes, provide an empty string
        :param str experimentname: The experiment name to filter by.
        :param list[int] output_projects: The project ids to filter by.
        :param list[str] include: Sub elements to include in the response
        :param list[str] propertynamestartswith: Filter properties by name starting with. Max items returned is 1024.
        :param list[str] excludepropertynamestartswith: Filter properties by name not starting with. Max items returned is 1024.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2RunCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['statuses', 'instrumenttype', 'laneandqcstatuses', 'flowcellbarcode', 'experimentname', 'output_projects', 'include', 'propertynamestartswith', 'excludepropertynamestartswith', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
        if 'instrumenttype' in params:
            query_params.append(('instrumenttype', params['instrumenttype']))  # noqa: E501
        if 'laneandqcstatuses' in params:
            query_params.append(('laneandqcstatuses', params['laneandqcstatuses']))  # noqa: E501
        if 'flowcellbarcode' in params:
            query_params.append(('flowcellbarcode', params['flowcellbarcode']))  # noqa: E501
        if 'experimentname' in params:
            query_params.append(('experimentname', params['experimentname']))  # noqa: E501
        if 'output_projects' in params:
            query_params.append(('output.projects', params['output_projects']))  # noqa: E501
            collection_formats['output.projects'] = 'csv'  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'propertynamestartswith' in params:
            query_params.append(('propertynamestartswith', params['propertynamestartswith']))  # noqa: E501
            collection_formats['propertynamestartswith'] = 'csv'  # noqa: E501
        if 'excludepropertynamestartswith' in params:
            query_params.append(('excludepropertynamestartswith', params['excludepropertynamestartswith']))  # noqa: E501
            collection_formats['excludepropertynamestartswith'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2RunCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_accesscheck(self, **kwargs):  # noqa: E501
        """get_v2_runs_accesscheck  # noqa: E501

        check user access for the run ids and returned filtered list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_accesscheck(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] ids:
        :return: list[V2RunAccess]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_accesscheck_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_accesscheck_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_runs_accesscheck_with_http_info(self, **kwargs):  # noqa: E501
        """get_v2_runs_accesscheck  # noqa: E501

        check user access for the run ids and returned filtered list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_accesscheck_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] ids:
        :return: list[V2RunAccess]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_accesscheck" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
            collection_formats['ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/accesscheck', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[V2RunAccess]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_id(self, id, **kwargs):  # noqa: E501
        """Get information about a run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param int propertieslimit:
        :param int propertyitemslimit:
        :param list[str] include:
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_runs_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param int propertieslimit:
        :param int propertyitemslimit:
        :param list[str] include:
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_runs_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_id_file_upload_info(self, id, **kwargs):  # noqa: E501
        """get_v2_runs_id_file_upload_info  # noqa: E501

        Request direct file upload presigned url information for a new file in the specified resource (sample or run)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_file_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str filepath:
        :param int uploadpartcount:
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_runs_id_file_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_runs_id_file_upload_info  # noqa: E501

        Request direct file upload presigned url information for a new file in the specified resource (sample or run)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_file_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str filepath:
        :param int uploadpartcount:
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'filepath', 'uploadpartcount']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_id_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_runs_id_file_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'filepath' in params:
            query_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'uploadpartcount' in params:
            query_params.append(('uploadpartcount', params['uploadpartcount']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/file-upload-info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PresignedUrlForUpload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_id_files(self, filehrefcontentresolution, recursive, id, **kwargs):  # noqa: E501
        """Get a list of files of a run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_files(filehrefcontentresolution, recursive, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool filehrefcontentresolution: Resolves the HrefContent to the direct file URI to avoid a hop to GET: files/{id}/content (required)
        :param bool recursive: If a 'directory' is provided, files in subfolders of the given directory are also included (required)
        :param str id: The Id of the resource (required)
        :param str extensions: The file extensions to filter by (comma-separated)
        :param str excludeextensions: The file extensions to exclude (comma-separated)
        :param str directory: The directory path to filter by (root is /)
        :param list[str] statuses: Optionally filter by status (default complete)
        :param list[str] include: Possible values: 'Subdirectories', 'TotalCount'
        :param str pathprefix: To be pre-fixed in the path of the file
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_id_files_with_http_info(filehrefcontentresolution, recursive, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_id_files_with_http_info(filehrefcontentresolution, recursive, id, **kwargs)  # noqa: E501
            return data

    def get_v2_runs_id_files_with_http_info(self, filehrefcontentresolution, recursive, id, **kwargs):  # noqa: E501
        """Get a list of files of a run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_files_with_http_info(filehrefcontentresolution, recursive, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool filehrefcontentresolution: Resolves the HrefContent to the direct file URI to avoid a hop to GET: files/{id}/content (required)
        :param bool recursive: If a 'directory' is provided, files in subfolders of the given directory are also included (required)
        :param str id: The Id of the resource (required)
        :param str extensions: The file extensions to filter by (comma-separated)
        :param str excludeextensions: The file extensions to exclude (comma-separated)
        :param str directory: The directory path to filter by (root is /)
        :param list[str] statuses: Optionally filter by status (default complete)
        :param list[str] include: Possible values: 'Subdirectories', 'TotalCount'
        :param str pathprefix: To be pre-fixed in the path of the file
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filehrefcontentresolution', 'recursive', 'id', 'extensions', 'excludeextensions', 'directory', 'statuses', 'include', 'pathprefix', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_id_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filehrefcontentresolution' is set
        if ('filehrefcontentresolution' not in params or
                params['filehrefcontentresolution'] is None):
            raise ValueError("Missing the required parameter `filehrefcontentresolution` when calling `get_v2_runs_id_files`")  # noqa: E501
        # verify the required parameter 'recursive' is set
        if ('recursive' not in params or
                params['recursive'] is None):
            raise ValueError("Missing the required parameter `recursive` when calling `get_v2_runs_id_files`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_runs_id_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'extensions' in params:
            query_params.append(('extensions', params['extensions']))  # noqa: E501
        if 'excludeextensions' in params:
            query_params.append(('excludeextensions', params['excludeextensions']))  # noqa: E501
        if 'directory' in params:
            query_params.append(('directory', params['directory']))  # noqa: E501
        if 'filehrefcontentresolution' in params:
            query_params.append(('filehrefcontentresolution', params['filehrefcontentresolution']))  # noqa: E501
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'csv'  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'pathprefix' in params:
            query_params.append(('pathprefix', params['pathprefix']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2FilesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_id_properties(self, id, **kwargs):  # noqa: E501
        """get_v2_runs_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_runs_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_runs_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_runs_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """get_v2_runs_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_runs_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_runs_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_runs_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_runs_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_id_properties_name_items(self, id, name, **kwargs):  # noqa: E501
        """get_v2_runs_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_properties_name_items(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_runs_id_properties_name_items_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_runs_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_properties_name_items_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_id_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_runs_id_properties_name_items`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_runs_id_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_id_samplesheet(self, id, **kwargs):  # noqa: E501
        """get_v2_runs_id_samplesheet  # noqa: E501

        Request run sample sheet  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_samplesheet(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2RunSampleSheet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_id_samplesheet_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_id_samplesheet_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_runs_id_samplesheet_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_runs_id_samplesheet  # noqa: E501

        Request run sample sheet  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_samplesheet_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2RunSampleSheet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_id_samplesheet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_runs_id_samplesheet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/samplesheet', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2RunSampleSheet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runs_id_sequencingstats(self, id, **kwargs):  # noqa: E501
        """get_v2_runs_id_sequencingstats  # noqa: E501

        Request sequencing stats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_sequencingstats(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2SequencingStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runs_id_sequencingstats_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runs_id_sequencingstats_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_runs_id_sequencingstats_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_runs_id_sequencingstats  # noqa: E501

        Request sequencing stats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runs_id_sequencingstats_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V2SequencingStats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runs_id_sequencingstats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_runs_id_sequencingstats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/sequencingstats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2SequencingStats',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_runuploadtest(self, **kwargs):  # noqa: E501
        """get_v2_runuploadtest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runuploadtest(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_runuploadtest_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_runuploadtest_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_runuploadtest_with_http_info(self, **kwargs):  # noqa: E501
        """get_v2_runuploadtest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_runuploadtest_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_runuploadtest" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runuploadtest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_samples_id_file_upload_info(self, id, **kwargs):  # noqa: E501
        """get_v2_samples_id_file_upload_info  # noqa: E501

        Request direct file upload presigned url information for a new file in the specified resource (sample or run)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_samples_id_file_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str filepath:
        :param int uploadpartcount:
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_samples_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_samples_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_samples_id_file_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_samples_id_file_upload_info  # noqa: E501

        Request direct file upload presigned url information for a new file in the specified resource (sample or run)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_samples_id_file_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str filepath:
        :param int uploadpartcount:
        :return: V2PresignedUrlForUpload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'filepath', 'uploadpartcount']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_samples_id_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_samples_id_file_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'filepath' in params:
            query_params.append(('filepath', params['filepath']))  # noqa: E501
        if 'uploadpartcount' in params:
            query_params.append(('uploadpartcount', params['uploadpartcount']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/samples/{id}/file-upload-info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PresignedUrlForUpload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_subjects_id_properties(self, id, **kwargs):  # noqa: E501
        """get_v2_subjects_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_subjects_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_subjects_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_subjects_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_subjects_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_v2_subjects_id_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_subjects_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_subjects_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_subjects_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_subjects_id_properties_name(self, id, name, **kwargs):  # noqa: E501
        """get_v2_subjects_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_subjects_id_properties_name(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_subjects_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_subjects_id_properties_name_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_subjects_id_properties_name_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_subjects_id_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_subjects_id_properties_name_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_subjects_id_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_subjects_id_properties_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_subjects_id_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{id}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_subjects_id_properties_name_items(self, id, name, **kwargs):  # noqa: E501
        """get_v2_subjects_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_subjects_id_properties_name_items(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_subjects_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_subjects_id_properties_name_items_with_http_info(id, name, **kwargs)  # noqa: E501
            return data

    def get_v2_subjects_id_properties_name_items_with_http_info(self, id, name, **kwargs):  # noqa: E501
        """get_v2_subjects_id_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_subjects_id_properties_name_items_with_http_info(id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name: Property name (required)
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_subjects_id_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_subjects_id_properties_name_items`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_subjects_id_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/subjects/{id}/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_trash(self, **kwargs):  # noqa: E501
        """Get a list of items in the trash  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_trash(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V1pre3TrashItemCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_trash_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_trash_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_trash_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of items in the trash  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_trash_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V1pre3TrashItemCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_trash" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/trash', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3TrashItemCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_trash_id(self, id, **kwargs):  # noqa: E501
        """Get information about an item in the trash  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_trash_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V1pre3TrashItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_trash_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_trash_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_trash_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about an item in the trash  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_trash_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :return: V1pre3TrashItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_trash_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_trash_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/trash/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3TrashItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_useragreements(self, **kwargs):  # noqa: E501
        """Get information about agreements visible to the current user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_useragreements(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str applicationid: If specified, only return agreements for this application. If not, only return agreements not associated with an application.
        :param str title: If specified, only return agreements with titles exactly matching the specified value.
        :param str category: If specified, only return agreements with category exactly matching the specified value.
        :param list[str] include: Expand or filter the agreements returned. Include=Expired will return expired agreements, giving a history of all agreements ever signed by the user. Include=Pending looks for agreements that the user hasn't signed yet.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2UserAgreementCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_useragreements_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_useragreements_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_useragreements_with_http_info(self, **kwargs):  # noqa: E501
        """Get information about agreements visible to the current user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_useragreements_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str applicationid: If specified, only return agreements for this application. If not, only return agreements not associated with an application.
        :param str title: If specified, only return agreements with titles exactly matching the specified value.
        :param str category: If specified, only return agreements with category exactly matching the specified value.
        :param list[str] include: Expand or filter the agreements returned. Include=Expired will return expired agreements, giving a history of all agreements ever signed by the user. Include=Pending looks for agreements that the user hasn't signed yet.
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2UserAgreementCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['applicationid', 'title', 'category', 'include', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_useragreements" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'applicationid' in params:
            query_params.append(('applicationid', params['applicationid']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/useragreements/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2UserAgreementCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current(self, **kwargs):  # noqa: E501
        """Get information about the current user's account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str options:
        :param list[str] include:
        :param str id: The Id of the resource
        :return: V2User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_users_current_with_http_info(self, **kwargs):  # noqa: E501
        """Get information about the current user's account  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str options:
        :param list[str] include:
        :param str id: The Id of the resource
        :return: V2User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['options', 'include', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'options' in params:
            query_params.append(('options', params['options']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current_labtype(self, **kwargs):  # noqa: E501
        """Is user a wet lab or dry lab user?  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_labtype(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_labtype_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_labtype_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_users_current_labtype_with_http_info(self, **kwargs):  # noqa: E501
        """Is user a wet lab or dry lab user?  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_labtype_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current_labtype" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/labtype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current_messages(self, **kwargs):  # noqa: E501
        """Get a list of messages that have been sent to the requesting user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_users_current_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of messages that have been sent to the requesting user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current_notifications(self, streamtype, attentionrequired, **kwargs):  # noqa: E501
        """get_v2_users_current_notifications  # noqa: E501

        List notifications for a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_notifications(streamtype, attentionrequired, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str streamtype: The classification of user notifications to receive. Applicable values are 'All', 'Activity', 'Storage', 'DataDeletion', 'Subscription', 'CMS'  (required)
        :param bool attentionrequired: AttentionRequired (required)
        :param str category: The category within a 'Stream' of user notifications to receive. Currently only 'Activity' Stream supports Categories. Applicable values are 'All', 'Run', 'AppSession', 'Invite'
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2UserNotificationCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_notifications_with_http_info(streamtype, attentionrequired, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_notifications_with_http_info(streamtype, attentionrequired, **kwargs)  # noqa: E501
            return data

    def get_v2_users_current_notifications_with_http_info(self, streamtype, attentionrequired, **kwargs):  # noqa: E501
        """get_v2_users_current_notifications  # noqa: E501

        List notifications for a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_notifications_with_http_info(streamtype, attentionrequired, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str streamtype: The classification of user notifications to receive. Applicable values are 'All', 'Activity', 'Storage', 'DataDeletion', 'Subscription', 'CMS'  (required)
        :param bool attentionrequired: AttentionRequired (required)
        :param str category: The category within a 'Stream' of user notifications to receive. Currently only 'Activity' Stream supports Categories. Applicable values are 'All', 'Run', 'AppSession', 'Invite'
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2UserNotificationCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['streamtype', 'attentionrequired', 'category', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current_notifications" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'streamtype' is set
        if ('streamtype' not in params or
                params['streamtype'] is None):
            raise ValueError("Missing the required parameter `streamtype` when calling `get_v2_users_current_notifications`")  # noqa: E501
        # verify the required parameter 'attentionrequired' is set
        if ('attentionrequired' not in params or
                params['attentionrequired'] is None):
            raise ValueError("Missing the required parameter `attentionrequired` when calling `get_v2_users_current_notifications`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'streamtype' in params:
            query_params.append(('streamtype', params['streamtype']))  # noqa: E501
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'attentionrequired' in params:
            query_params.append(('attentionrequired', params['attentionrequired']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/notifications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2UserNotificationCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current_properties(self, **kwargs):  # noqa: E501
        """get_v2_users_current_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_properties(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id:
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_properties_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_properties_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v2_users_current_properties_with_http_info(self, **kwargs):  # noqa: E501
        """get_v2_users_current_properties  # noqa: E501

        List properties for a resource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_properties_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id:
        :param int propertieslimit: Limit the # of properties returned
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param list[str] propertyfilters: Filter by property name
        :param str showhiddenitems: Show Hidden projects and Datasets
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'propertieslimit', 'propertyitemslimit', 'propertyfilters', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current_properties" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'propertieslimit' in params:
            query_params.append(('propertieslimit', params['propertieslimit']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'propertyfilters' in params:
            query_params.append(('propertyfilters', params['propertyfilters']))  # noqa: E501
            collection_formats['propertyfilters'] = 'csv'  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current_properties_name(self, name, **kwargs):  # noqa: E501
        """get_v2_users_current_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_properties_name(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Property name (required)
        :param str id:
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_properties_name_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_properties_name_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_v2_users_current_properties_name_with_http_info(self, name, **kwargs):  # noqa: E501
        """get_v2_users_current_properties_name  # noqa: E501

        Get property information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_properties_name_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Property name (required)
        :param str id:
        :param int propertyitemslimit: Limit the # of property items returned per property
        :param str showhiddenitems: Hidden filter
        :return: V2Property
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'id', 'propertyitemslimit', 'showhiddenitems']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current_properties_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_users_current_properties_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'propertyitemslimit' in params:
            query_params.append(('propertyitemslimit', params['propertyitemslimit']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Property',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current_properties_name_items(self, name, **kwargs):  # noqa: E501
        """get_v2_users_current_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_properties_name_items(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Property name (required)
        :param str id:
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_properties_name_items_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_properties_name_items_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_v2_users_current_properties_name_items_with_http_info(self, name, **kwargs):  # noqa: E501
        """get_v2_users_current_properties_name_items  # noqa: E501

        Get property item details  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_properties_name_items_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Property name (required)
        :param str id:
        :param str showhiddenitems: Hidden filter
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2PropertyItemList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'id', 'showhiddenitems', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current_properties_name_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_v2_users_current_properties_name_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'showhiddenitems' in params:
            query_params.append(('showhiddenitems', params['showhiddenitems']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/properties/{name}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyItemList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current_subscription(self, refreshcache, **kwargs):  # noqa: E501
        """Get information about the current users subscriptions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_subscription(refreshcache, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool refreshcache: (required)
        :param str id: The Id of the resource
        :return: V2UserSubscription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_subscription_with_http_info(refreshcache, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_subscription_with_http_info(refreshcache, **kwargs)  # noqa: E501
            return data

    def get_v2_users_current_subscription_with_http_info(self, refreshcache, **kwargs):  # noqa: E501
        """Get information about the current users subscriptions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_subscription_with_http_info(refreshcache, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool refreshcache: (required)
        :param str id: The Id of the resource
        :return: V2UserSubscription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refreshcache', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refreshcache' is set
        if ('refreshcache' not in params or
                params['refreshcache'] is None):
            raise ValueError("Missing the required parameter `refreshcache` when calling `get_v2_users_current_subscription`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'refreshcache' in params:
            query_params.append(('refreshcache', params['refreshcache']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/subscription', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2UserSubscription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_current_usage(self, includeloggedinuser, periods, refreshcache, **kwargs):  # noqa: E501
        """Get usage statistics for the user  # noqa: E501

        Information about storage and compute usage will be returned for the users personal account, as well as any workgroups they own.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_usage(includeloggedinuser, periods, refreshcache, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool includeloggedinuser: (required)
        :param int periods: (required)
        :param bool refreshcache: (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2PeriodAggregateUsageList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_current_usage_with_http_info(includeloggedinuser, periods, refreshcache, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_current_usage_with_http_info(includeloggedinuser, periods, refreshcache, **kwargs)  # noqa: E501
            return data

    def get_v2_users_current_usage_with_http_info(self, includeloggedinuser, periods, refreshcache, **kwargs):  # noqa: E501
        """Get usage statistics for the user  # noqa: E501

        Information about storage and compute usage will be returned for the users personal account, as well as any workgroups they own.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_current_usage_with_http_info(includeloggedinuser, periods, refreshcache, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool includeloggedinuser: (required)
        :param int periods: (required)
        :param bool refreshcache: (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :param str id: The Id of the resource
        :return: V2PeriodAggregateUsageList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['includeloggedinuser', 'periods', 'refreshcache', 'sortby', 'offset', 'limit', 'sortdir', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_current_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'includeloggedinuser' is set
        if ('includeloggedinuser' not in params or
                params['includeloggedinuser'] is None):
            raise ValueError("Missing the required parameter `includeloggedinuser` when calling `get_v2_users_current_usage`")  # noqa: E501
        # verify the required parameter 'periods' is set
        if ('periods' not in params or
                params['periods'] is None):
            raise ValueError("Missing the required parameter `periods` when calling `get_v2_users_current_usage`")  # noqa: E501
        # verify the required parameter 'refreshcache' is set
        if ('refreshcache' not in params or
                params['refreshcache'] is None):
            raise ValueError("Missing the required parameter `refreshcache` when calling `get_v2_users_current_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'includeloggedinuser' in params:
            query_params.append(('includeloggedinuser', params['includeloggedinuser']))  # noqa: E501
        if 'periods' in params:
            query_params.append(('periods', params['periods']))  # noqa: E501
        if 'refreshcache' in params:
            query_params.append(('refreshcache', params['refreshcache']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PeriodAggregateUsageList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_id(self, id, **kwargs):  # noqa: E501
        """Get information about a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str options:
        :param list[str] include:
        :return: V2User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_users_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str options:
        :param list[str] include:
        :return: V2User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'options', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_users_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'options' in params:
            query_params.append(('options', params['options']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_id_autodeletionevents(self, id, **kwargs):  # noqa: E501
        """Get a list of auto-deletion events for the specified user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_autodeletionevents(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_id_autodeletionevents_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_id_autodeletionevents_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_users_id_autodeletionevents_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of auto-deletion events for the specified user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_autodeletionevents_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_id_autodeletionevents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_users_id_autodeletionevents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}/autodeletionevents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_id_messages(self, id, **kwargs):  # noqa: E501
        """Get a list of messages that have been sent to a specific user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_messages(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_id_messages_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_id_messages_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_users_id_messages_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of messages that have been sent to a specific user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_messages_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_id_messages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_users_id_messages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_id_notifications(self, streamtype, attentionrequired, id, **kwargs):  # noqa: E501
        """get_v2_users_id_notifications  # noqa: E501

        List notifications for a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_notifications(streamtype, attentionrequired, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str streamtype: The classification of user notifications to receive. Applicable values are 'All', 'Activity', 'Storage', 'DataDeletion', 'Subscription', 'CMS'  (required)
        :param bool attentionrequired: AttentionRequired (required)
        :param str id: The Id of the resource (required)
        :param str category: The category within a 'Stream' of user notifications to receive. Currently only 'Activity' Stream supports Categories. Applicable values are 'All', 'Run', 'AppSession', 'Invite'
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2UserNotificationCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_id_notifications_with_http_info(streamtype, attentionrequired, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_id_notifications_with_http_info(streamtype, attentionrequired, id, **kwargs)  # noqa: E501
            return data

    def get_v2_users_id_notifications_with_http_info(self, streamtype, attentionrequired, id, **kwargs):  # noqa: E501
        """get_v2_users_id_notifications  # noqa: E501

        List notifications for a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_notifications_with_http_info(streamtype, attentionrequired, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str streamtype: The classification of user notifications to receive. Applicable values are 'All', 'Activity', 'Storage', 'DataDeletion', 'Subscription', 'CMS'  (required)
        :param bool attentionrequired: AttentionRequired (required)
        :param str id: The Id of the resource (required)
        :param str category: The category within a 'Stream' of user notifications to receive. Currently only 'Activity' Stream supports Categories. Applicable values are 'All', 'Run', 'AppSession', 'Invite'
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2UserNotificationCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['streamtype', 'attentionrequired', 'id', 'category', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_id_notifications" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'streamtype' is set
        if ('streamtype' not in params or
                params['streamtype'] is None):
            raise ValueError("Missing the required parameter `streamtype` when calling `get_v2_users_id_notifications`")  # noqa: E501
        # verify the required parameter 'attentionrequired' is set
        if ('attentionrequired' not in params or
                params['attentionrequired'] is None):
            raise ValueError("Missing the required parameter `attentionrequired` when calling `get_v2_users_id_notifications`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_users_id_notifications`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'streamtype' in params:
            query_params.append(('streamtype', params['streamtype']))  # noqa: E501
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'attentionrequired' in params:
            query_params.append(('attentionrequired', params['attentionrequired']))  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}/notifications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2UserNotificationCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_id_settings(self, id, **kwargs):  # noqa: E501
        """Get a list of the user's settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_settings(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2UserSettingList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_id_settings_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_id_settings_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_users_id_settings_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a list of the user's settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_settings_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2UserSettingList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_id_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_users_id_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2UserSettingList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_id_subscription(self, refreshcache, id, **kwargs):  # noqa: E501
        """Get information about a user's subscriptions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_subscription(refreshcache, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool refreshcache: (required)
        :param str id: The Id of the resource (required)
        :return: V2UserSubscription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_id_subscription_with_http_info(refreshcache, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_id_subscription_with_http_info(refreshcache, id, **kwargs)  # noqa: E501
            return data

    def get_v2_users_id_subscription_with_http_info(self, refreshcache, id, **kwargs):  # noqa: E501
        """Get information about a user's subscriptions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_subscription_with_http_info(refreshcache, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool refreshcache: (required)
        :param str id: The Id of the resource (required)
        :return: V2UserSubscription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refreshcache', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_id_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refreshcache' is set
        if ('refreshcache' not in params or
                params['refreshcache'] is None):
            raise ValueError("Missing the required parameter `refreshcache` when calling `get_v2_users_id_subscription`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_users_id_subscription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'refreshcache' in params:
            query_params.append(('refreshcache', params['refreshcache']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}/subscription', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2UserSubscription',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_users_id_workgroups(self, includeloggedinuser, activeonly, refreshcache, includesubscription, id, **kwargs):  # noqa: E501
        """Get a list of workgroups the user belongs to  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_workgroups(includeloggedinuser, activeonly, refreshcache, includesubscription, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool includeloggedinuser: Includes current user (required)
        :param bool activeonly: Excludes inactive workgroups (required)
        :param bool refreshcache: This will force a refresh on the workgroup subscriptions (required)
        :param bool includesubscription: This will include subscription in the response (required)
        :param str id: The Id of the resource (required)
        :param list[str] include: Sub elements to include in the response: LoggedInUser, IsDefaultRunUploadWorkgroup
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2WorkgroupList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_users_id_workgroups_with_http_info(includeloggedinuser, activeonly, refreshcache, includesubscription, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_users_id_workgroups_with_http_info(includeloggedinuser, activeonly, refreshcache, includesubscription, id, **kwargs)  # noqa: E501
            return data

    def get_v2_users_id_workgroups_with_http_info(self, includeloggedinuser, activeonly, refreshcache, includesubscription, id, **kwargs):  # noqa: E501
        """Get a list of workgroups the user belongs to  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_users_id_workgroups_with_http_info(includeloggedinuser, activeonly, refreshcache, includesubscription, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool includeloggedinuser: Includes current user (required)
        :param bool activeonly: Excludes inactive workgroups (required)
        :param bool refreshcache: This will force a refresh on the workgroup subscriptions (required)
        :param bool includesubscription: This will include subscription in the response (required)
        :param str id: The Id of the resource (required)
        :param list[str] include: Sub elements to include in the response: LoggedInUser, IsDefaultRunUploadWorkgroup
        :param str sortby: The field(s) used to sort the result set
        :param int offset: The starting offset to read
        :param int limit: The maximum number of items to return
        :param str sortdir: The sort direction for the result set
        :return: V2WorkgroupList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['includeloggedinuser', 'activeonly', 'refreshcache', 'includesubscription', 'id', 'include', 'sortby', 'offset', 'limit', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_users_id_workgroups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'includeloggedinuser' is set
        if ('includeloggedinuser' not in params or
                params['includeloggedinuser'] is None):
            raise ValueError("Missing the required parameter `includeloggedinuser` when calling `get_v2_users_id_workgroups`")  # noqa: E501
        # verify the required parameter 'activeonly' is set
        if ('activeonly' not in params or
                params['activeonly'] is None):
            raise ValueError("Missing the required parameter `activeonly` when calling `get_v2_users_id_workgroups`")  # noqa: E501
        # verify the required parameter 'refreshcache' is set
        if ('refreshcache' not in params or
                params['refreshcache'] is None):
            raise ValueError("Missing the required parameter `refreshcache` when calling `get_v2_users_id_workgroups`")  # noqa: E501
        # verify the required parameter 'includesubscription' is set
        if ('includesubscription' not in params or
                params['includesubscription'] is None):
            raise ValueError("Missing the required parameter `includesubscription` when calling `get_v2_users_id_workgroups`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_users_id_workgroups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'includeloggedinuser' in params:
            query_params.append(('includeloggedinuser', params['includeloggedinuser']))  # noqa: E501
        if 'activeonly' in params:
            query_params.append(('activeonly', params['activeonly']))  # noqa: E501
        if 'refreshcache' in params:
            query_params.append(('refreshcache', params['refreshcache']))  # noqa: E501
        if 'includesubscription' in params:
            query_params.append(('includesubscription', params['includesubscription']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
            collection_formats['include'] = 'csv'  # noqa: E501
        if 'sortby' in params:
            query_params.append(('sortby', params['sortby']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}/workgroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2WorkgroupList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_v2migration_status_stepname(self, stepname, **kwargs):  # noqa: E501
        """Get status report on migration   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_v2migration_status_stepname(stepname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stepname: Migration Step Name (required)
        :param str id: The Id of the resource
        :return: V2MigrationStatusReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_v2migration_status_stepname_with_http_info(stepname, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_v2migration_status_stepname_with_http_info(stepname, **kwargs)  # noqa: E501
            return data

    def get_v2_v2migration_status_stepname_with_http_info(self, stepname, **kwargs):  # noqa: E501
        """Get status report on migration   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_v2migration_status_stepname_with_http_info(stepname, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stepname: Migration Step Name (required)
        :param str id: The Id of the resource
        :return: V2MigrationStatusReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stepname', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_v2migration_status_stepname" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'stepname' is set
        if ('stepname' not in params or
                params['stepname'] is None):
            raise ValueError("Missing the required parameter `stepname` when calling `get_v2_v2migration_status_stepname`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stepname' in params:
            path_params['stepname'] = params['stepname']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            'migration/status/{stepname}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2MigrationStatusReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v2_workgroups_id(self, id, **kwargs):  # noqa: E501
        """Get information about a workgroup  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_workgroups_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Workgroup ID (required)
        :return: V2Workgroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v2_workgroups_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_v2_workgroups_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_v2_workgroups_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a workgroup  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v2_workgroups_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Workgroup ID (required)
        :return: V2Workgroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v2_workgroups_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_v2_workgroups_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/workgroups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Workgroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_applications_id_workflows(self, id, **kwargs):  # noqa: E501
        """Create or update an analysis workflow  # noqa: E501

        Create an analysis workflow using the settings, app, and version of an existing appsession.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_applications_id_workflows(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Applicaiton Id (required)
        :param V2PostApplicationIdWorkflowsRequest body:
        :return: IApplicationCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_applications_id_workflows_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_applications_id_workflows_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_applications_id_workflows_with_http_info(self, id, **kwargs):  # noqa: E501
        """Create or update an analysis workflow  # noqa: E501

        Create an analysis workflow using the settings, app, and version of an existing appsession.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_applications_id_workflows_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Applicaiton Id (required)
        :param V2PostApplicationIdWorkflowsRequest body:
        :return: IApplicationCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_applications_id_workflows" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_applications_id_workflows`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}/workflows', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IApplicationCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appresults_id_file_upload_info(self, id, **kwargs):  # noqa: E501
        """post_v2_appresults_id_file_upload_info  # noqa: E501

        Complete multipart upload and report uploaded files to a resource (dataset or appresult)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appresults_id_file_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2ResourcePresignedUrlCompleteRequestForEveryone body:
        :return: V1pre3FileCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appresults_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appresults_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_appresults_id_file_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """post_v2_appresults_id_file_upload_info  # noqa: E501

        Complete multipart upload and report uploaded files to a resource (dataset or appresult)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appresults_id_file_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2ResourcePresignedUrlCompleteRequestForEveryone body:
        :return: V1pre3FileCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appresults_id_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_appresults_id_file_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appresults/{id}/file-upload-info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3FileCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appsessions(self, **kwargs):  # noqa: E501
        """Create a new interactive AppSession with ExecutionStatus Running  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostAppsessionsRequest body:
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appsessions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appsessions_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_appsessions_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new interactive AppSession with ExecutionStatus Running  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostAppsessionsRequest body:
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appsessions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appsessions_id(self, id, **kwargs):  # noqa: E501
        """Update an analysis  # noqa: E501

        The Execution Status cannot be changed since it is an automated status tracking the progress of running the app. The Qc Status may be updated only when the Execution Status is set to Complete or Aborted. Delivery Status may be updated at any time. Comments can be added when updating statuses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param V2PostAppSessionsIdRequest body:
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appsessions_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appsessions_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_appsessions_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an analysis  # noqa: E501

        The Execution Status cannot be changed since it is an automated status tracking the progress of running the app. The Qc Status may be updated only when the Execution Status is set to Complete or Aborted. Delivery Status may be updated at any time. Comments can be added when updating statuses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param V2PostAppSessionsIdRequest body:
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appsessions_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_appsessions_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appsessions_id_logfiles(self, id, **kwargs):  # noqa: E501
        """Add a log file to a specific analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_logfiles(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param V2PostAppSessionsIdFilesRequest body:
        :return: V2FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appsessions_id_logfiles_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appsessions_id_logfiles_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_appsessions_id_logfiles_with_http_info(self, id, **kwargs):  # noqa: E501
        """Add a log file to a specific analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_logfiles_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param V2PostAppSessionsIdFilesRequest body:
        :return: V2FilesList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appsessions_id_logfiles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_appsessions_id_logfiles`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/logfiles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2FilesList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appsessions_id_properties(self, id, **kwargs):  # noqa: E501
        """Add or update properties of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_properties(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param V2PostAppSessionsPropertiesRequest body:
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appsessions_id_properties_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appsessions_id_properties_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_appsessions_id_properties_with_http_info(self, id, **kwargs):  # noqa: E501
        """Add or update properties of an analysis  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_properties_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param V2PostAppSessionsPropertiesRequest body:
        :return: V2PropertyCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appsessions_id_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_appsessions_id_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2PropertyCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appsessions_id_reschedule(self, id, **kwargs):  # noqa: E501
        """Reschedule a workflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_reschedule(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param V2PostAppSessionsIdRescheduleRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appsessions_id_reschedule_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appsessions_id_reschedule_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_appsessions_id_reschedule_with_http_info(self, id, **kwargs):  # noqa: E501
        """Reschedule a workflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_reschedule_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param V2PostAppSessionsIdRescheduleRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appsessions_id_reschedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_appsessions_id_reschedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/reschedule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appsessions_id_stop(self, id, **kwargs):  # noqa: E501
        """Stop an analysis from running  # noqa: E501

        The analysis must have a status of Running or Pending.  Stopping a running analysis will update the status to Aborted.  Stopping a pending analysis will update the status to Canceled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_stop(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param V2PostAppSessionsIdStopRequest body:
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appsessions_id_stop_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appsessions_id_stop_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_appsessions_id_stop_with_http_info(self, id, **kwargs):  # noqa: E501
        """Stop an analysis from running  # noqa: E501

        The analysis must have a status of Running or Pending.  Stopping a running analysis will update the status to Aborted.  Stopping a pending analysis will update the status to Canceled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_id_stop_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Appsession ID (required)
        :param V2PostAppSessionsIdStopRequest body:
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appsessions_id_stop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_appsessions_id_stop`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/{id}/stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appsessions_track(self, **kwargs):  # noqa: E501
        """Track ICA analyses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_track(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostAppSessionsTrackRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appsessions_track_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appsessions_track_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_appsessions_track_with_http_info(self, **kwargs):  # noqa: E501
        """Track ICA analyses  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_track_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostAppSessionsTrackRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appsessions_track" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/track', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_appsessions_workflowsessions_track(self, **kwargs):  # noqa: E501
        """Track workflow sessions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_workflowsessions_track(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostAppSessionsWorkflowSessionsTrackRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_appsessions_workflowsessions_track_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_appsessions_workflowsessions_track_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_appsessions_workflowsessions_track_with_http_info(self, **kwargs):  # noqa: E501
        """Track workflow sessions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_appsessions_workflowsessions_track_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostAppSessionsWorkflowSessionsTrackRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_appsessions_workflowsessions_track" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/appsessions/workflowsessions/track', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_archive(self, **kwargs):  # noqa: E501
        """Bulk archive.  # noqa: E501

        Archive one or more Runs or Projects.  The status will update right away, but the archive process itself is async.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_archive(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BulkArchiveRequest body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_archive_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_archive_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_archive_with_http_info(self, **kwargs):  # noqa: E501
        """Bulk archive.  # noqa: E501

        Archive one or more Runs or Projects.  The status will update right away, but the archive process itself is async.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_archive_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BulkArchiveRequest body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_archive" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_biosamples(self, **kwargs):  # noqa: E501
        """post_v2_biosamples  # noqa: E501

        Create a biological sample.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2CreateBiologicalSampleRequest body:
        :return: V2BiologicalSample
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_biosamples_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_biosamples_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_biosamples_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_biosamples  # noqa: E501

        Create a biological sample.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2CreateBiologicalSampleRequest body:
        :return: V2BiologicalSample
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_biosamples" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2BiologicalSample',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_biosamples_bulkupdate(self, **kwargs):  # noqa: E501
        """Update the default project of many biosamples  # noqa: E501

        Setting a new default project of a biosample will redirect newly created datasets to the new project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_bulkupdate(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostBioSamplesBulkUpdateRequest body:
        :return: IBiologicalSampleCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_biosamples_bulkupdate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_biosamples_bulkupdate_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_biosamples_bulkupdate_with_http_info(self, **kwargs):  # noqa: E501
        """Update the default project of many biosamples  # noqa: E501

        Setting a new default project of a biosample will redirect newly created datasets to the new project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_bulkupdate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostBioSamplesBulkUpdateRequest body:
        :return: IBiologicalSampleCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_biosamples_bulkupdate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/bulkupdate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IBiologicalSampleCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_biosamples_id(self, id, **kwargs):  # noqa: E501
        """Update a Biosample  # noqa: E501

        Setting a new default project of a biosample will redirect newly created datasets to the new project. The biosample status may transition between any of the possible statuses. Setting a biosample to canceled will automatically cancel all analyses in progress for that biosample.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param V2UpdateBiologicalSampleRequest body:
        :return: V2BiologicalSample
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_biosamples_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_biosamples_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_biosamples_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a Biosample  # noqa: E501

        Setting a new default project of a biosample will redirect newly created datasets to the new project. The biosample status may transition between any of the possible statuses. Setting a biosample to canceled will automatically cancel all analyses in progress for that biosample.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Biosample ID (required)
        :param V2UpdateBiologicalSampleRequest body:
        :return: V2BiologicalSample
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_biosamples_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_biosamples_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2BiologicalSample',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_biosamples_id_aggregation(self, id, **kwargs):  # noqa: E501
        """Update Biosample aggregation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_id_aggregation(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostBioSamplesIdAggregationRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_biosamples_id_aggregation_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_biosamples_id_aggregation_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_biosamples_id_aggregation_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Biosample aggregation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_id_aggregation_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostBioSamplesIdAggregationRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_biosamples_id_aggregation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_biosamples_id_aggregation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}/aggregation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_biosamples_id_libraries(self, id, **kwargs):  # noqa: E501
        """Create a library for a biosample  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_id_libraries(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostBiosampleLibraryRequest body:
        :return: V2LibraryCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_biosamples_id_libraries_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_biosamples_id_libraries_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_biosamples_id_libraries_with_http_info(self, id, **kwargs):  # noqa: E501
        """Create a library for a biosample  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_biosamples_id_libraries_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostBiosampleLibraryRequest body:
        :return: V2LibraryCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_biosamples_id_libraries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_biosamples_id_libraries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/biosamples/{id}/libraries', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LibraryCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_datacompress(self, **kwargs):  # noqa: E501
        """Bulk Data Compression.  # noqa: E501

        Queue one or more resources for data compression.  Compression process is async.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datacompress(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BulkDataCompressRequest body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_datacompress_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_datacompress_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_datacompress_with_http_info(self, **kwargs):  # noqa: E501
        """Bulk Data Compression.  # noqa: E501

        Queue one or more resources for data compression.  Compression process is async.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datacompress_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BulkDataCompressRequest body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_datacompress" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datacompress', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_datasets(self, **kwargs):  # noqa: E501
        """Create a dataset that doesn't belong in a specific project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostDatasetsRequest body:
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_datasets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_datasets_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_datasets_with_http_info(self, **kwargs):  # noqa: E501
        """Create a dataset that doesn't belong in a specific project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostDatasetsRequest body:
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_datasets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_datasets_id(self, id, **kwargs):  # noqa: E501
        """Update an existing dataset  # noqa: E501

        The QcStatus of a dataset may only be updated when the UploadStatus is set to Complete. The QcStatus may then be updated to one of the following values: QcFailed or QcPassed. A comment may be entered into the Comment field when updating the dataset QcStatus.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dataset ID (required)
        :param V2PostDatasetsIdRequest body:
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_datasets_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_datasets_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_datasets_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an existing dataset  # noqa: E501

        The QcStatus of a dataset may only be updated when the UploadStatus is set to Complete. The QcStatus may then be updated to one of the following values: QcFailed or QcPassed. A comment may be entered into the Comment field when updating the dataset QcStatus.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Dataset ID (required)
        :param V2PostDatasetsIdRequest body:
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_datasets_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_datasets_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_datasets_id_copy(self, id, **kwargs):  # noqa: E501
        """Copy a dataset to a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_copy(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostDatasetsIdCopyRequest body:
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_datasets_id_copy_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_datasets_id_copy_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_datasets_id_copy_with_http_info(self, id, **kwargs):  # noqa: E501
        """Copy a dataset to a project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_copy_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostDatasetsIdCopyRequest body:
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_datasets_id_copy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_datasets_id_copy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_datasets_id_direct_upload_info(self, id, **kwargs):  # noqa: E501
        """post_v2_datasets_id_direct_upload_info  # noqa: E501

        Report uploaded files to a dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_direct_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V1pre3PostDatasetIdDirectUploadInfoRequest body:
        :param str sortdir: The sort direction for the result set
        :return: V1pre3FileCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_datasets_id_direct_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_datasets_id_direct_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_datasets_id_direct_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """post_v2_datasets_id_direct_upload_info  # noqa: E501

        Report uploaded files to a dataset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_direct_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V1pre3PostDatasetIdDirectUploadInfoRequest body:
        :param str sortdir: The sort direction for the result set
        :return: V1pre3FileCompactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'sortdir']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_datasets_id_direct_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_datasets_id_direct_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'sortdir' in params:
            query_params.append(('sortdir', params['sortdir']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/direct-upload-info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3FileCompactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_datasets_id_file_upload_info(self, id, **kwargs):  # noqa: E501
        """post_v2_datasets_id_file_upload_info  # noqa: E501

        Complete multipart upload and report uploaded files to a resource (dataset or appresult)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_file_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2ResourcePresignedUrlCompleteRequestForEveryone body:
        :return: V1pre3FileCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_datasets_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_datasets_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_datasets_id_file_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """post_v2_datasets_id_file_upload_info  # noqa: E501

        Complete multipart upload and report uploaded files to a resource (dataset or appresult)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_file_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2ResourcePresignedUrlCompleteRequestForEveryone body:
        :return: V1pre3FileCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_datasets_id_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_datasets_id_file_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/file-upload-info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3FileCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_datasets_id_files(self, file, id, **kwargs):  # noqa: E501
        """post_v2_datasets_id_files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_files(file, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str id: The Id of the resource (required)
        :return: V1pre3File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_datasets_id_files_with_http_info(file, id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_datasets_id_files_with_http_info(file, id, **kwargs)  # noqa: E501
            return data

    def post_v2_datasets_id_files_with_http_info(self, file, id, **kwargs):  # noqa: E501
        """post_v2_datasets_id_files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_datasets_id_files_with_http_info(file, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str id: The Id of the resource (required)
        :return: V1pre3File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_datasets_id_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `post_v2_datasets_id_files`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_datasets_id_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/datasets/{id}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_icadownloads_create_download_url(self, **kwargs):  # noqa: E501
        """post_v2_icadownloads_create_download_url  # noqa: E501

        Get download url for data on ICA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_icadownloads_create_download_url(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2IcaFileCreateDownloadUrlRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_icadownloads_create_download_url_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_icadownloads_create_download_url_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_icadownloads_create_download_url_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_icadownloads_create_download_url  # noqa: E501

        Get download url for data on ICA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_icadownloads_create_download_url_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2IcaFileCreateDownloadUrlRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_icadownloads_create_download_url" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/icadownloads/create-download-url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_icauploads_foldertype_complete_upload(self, foldertype, **kwargs):  # noqa: E501
        """post_v2_icauploads_foldertype_complete_upload  # noqa: E501

        Complete file(s) upload to ICA, and respond with meta data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_icauploads_foldertype_complete_upload(foldertype, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str foldertype: (required)
        :param V2IcaCompleteUploadRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_icauploads_foldertype_complete_upload_with_http_info(foldertype, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_icauploads_foldertype_complete_upload_with_http_info(foldertype, **kwargs)  # noqa: E501
            return data

    def post_v2_icauploads_foldertype_complete_upload_with_http_info(self, foldertype, **kwargs):  # noqa: E501
        """post_v2_icauploads_foldertype_complete_upload  # noqa: E501

        Complete file(s) upload to ICA, and respond with meta data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_icauploads_foldertype_complete_upload_with_http_info(foldertype, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str foldertype: (required)
        :param V2IcaCompleteUploadRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['foldertype', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_icauploads_foldertype_complete_upload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'foldertype' is set
        if ('foldertype' not in params or
                params['foldertype'] is None):
            raise ValueError("Missing the required parameter `foldertype` when calling `post_v2_icauploads_foldertype_complete_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'foldertype' in params:
            path_params['foldertype'] = params['foldertype']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/icauploads/{foldertype}/complete-upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_icauploads_foldertype_direct_upload_info(self, foldertype, **kwargs):  # noqa: E501
        """post_v2_icauploads_foldertype_direct_upload_info  # noqa: E501

        Get upload destination on ICA and temporary upload credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_icauploads_foldertype_direct_upload_info(foldertype, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str foldertype: (required)
        :param V2IcaFileUploadRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_icauploads_foldertype_direct_upload_info_with_http_info(foldertype, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_icauploads_foldertype_direct_upload_info_with_http_info(foldertype, **kwargs)  # noqa: E501
            return data

    def post_v2_icauploads_foldertype_direct_upload_info_with_http_info(self, foldertype, **kwargs):  # noqa: E501
        """post_v2_icauploads_foldertype_direct_upload_info  # noqa: E501

        Get upload destination on ICA and temporary upload credentials  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_icauploads_foldertype_direct_upload_info_with_http_info(foldertype, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str foldertype: (required)
        :param V2IcaFileUploadRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['foldertype', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_icauploads_foldertype_direct_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'foldertype' is set
        if ('foldertype' not in params or
                params['foldertype'] is None):
            raise ValueError("Missing the required parameter `foldertype` when calling `post_v2_icauploads_foldertype_direct_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'foldertype' in params:
            path_params['foldertype'] = params['foldertype']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/icauploads/{foldertype}/direct-upload-info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_instrumentdiagnostics(self, **kwargs):  # noqa: E501
        """post_v2_instrumentdiagnostics  # noqa: E501

        Create non-run instrument diagnostic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_instrumentdiagnostics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2CreateInstrumentDiagnosticRequest body:
        :return: V2InstrumentDiagnostic
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_instrumentdiagnostics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_instrumentdiagnostics_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_instrumentdiagnostics_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_instrumentdiagnostics  # noqa: E501

        Create non-run instrument diagnostic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_instrumentdiagnostics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2CreateInstrumentDiagnosticRequest body:
        :return: V2InstrumentDiagnostic
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_instrumentdiagnostics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/instrumentdiagnostics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2InstrumentDiagnostic',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_instrumentdiagnostics_id(self, id, **kwargs):  # noqa: E501
        """post_v2_instrumentdiagnostics_id  # noqa: E501

        Update non-run instrument diagnostic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_instrumentdiagnostics_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2UpdateInstrumentDiagnosticRequest body:
        :return: V2InstrumentDiagnostic
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_instrumentdiagnostics_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_instrumentdiagnostics_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_instrumentdiagnostics_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """post_v2_instrumentdiagnostics_id  # noqa: E501

        Update non-run instrument diagnostic data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_instrumentdiagnostics_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2UpdateInstrumentDiagnosticRequest body:
        :return: V2InstrumentDiagnostic
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_instrumentdiagnostics_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_instrumentdiagnostics_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/instrumentdiagnostics/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2InstrumentDiagnostic',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_instruments_errors(self, **kwargs):  # noqa: E501
        """post_v2_instruments_errors  # noqa: E501

        Post instrument errors.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_instruments_errors(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostInstrumentErrorsRequest body:
        :return: V2InstrumentErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_instruments_errors_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_instruments_errors_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_instruments_errors_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_instruments_errors  # noqa: E501

        Post instrument errors.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_instruments_errors_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostInstrumentErrorsRequest body:
        :return: V2InstrumentErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_instruments_errors" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/instruments/errors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2InstrumentErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_lanes_id(self, id, **kwargs):  # noqa: E501
        """Update a lane  # noqa: E501

        The status of a lane may be updated to the following values: QcFailed, QcPassed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_lanes_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param V2PostLanesIdRequest body:
        :return: Lane
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_lanes_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_lanes_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_lanes_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a lane  # noqa: E501

        The status of a lane may be updated to the following values: QcFailed, QcPassed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_lanes_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param V2PostLanesIdRequest body:
        :return: Lane
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_lanes_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_lanes_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/lanes/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Lane',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_libraries_libraryid_labrequeues(self, libraryid, **kwargs):  # noqa: E501
        """Add a lab requeue request for more yield from a library  # noqa: E501

        The requested additional yield is the total yield to be requested for the whole pool. To estimate how much yield will be added from each library, divide the requested additional yield by the number of libraries in the pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_libraries_libraryid_labrequeues(libraryid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str libraryid: (required)
        :param V2CreateExistingLibraryLabRequeueRequest body:
        :return: V2LabRequeue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_libraries_libraryid_labrequeues_with_http_info(libraryid, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_libraries_libraryid_labrequeues_with_http_info(libraryid, **kwargs)  # noqa: E501
            return data

    def post_v2_libraries_libraryid_labrequeues_with_http_info(self, libraryid, **kwargs):  # noqa: E501
        """Add a lab requeue request for more yield from a library  # noqa: E501

        The requested additional yield is the total yield to be requested for the whole pool. To estimate how much yield will be added from each library, divide the requested additional yield by the number of libraries in the pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_libraries_libraryid_labrequeues_with_http_info(libraryid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str libraryid: (required)
        :param V2CreateExistingLibraryLabRequeueRequest body:
        :return: V2LabRequeue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['libraryid', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_libraries_libraryid_labrequeues" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'libraryid' is set
        if ('libraryid' not in params or
                params['libraryid'] is None):
            raise ValueError("Missing the required parameter `libraryid` when calling `post_v2_libraries_libraryid_labrequeues`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'libraryid' in params:
            path_params['libraryid'] = params['libraryid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/libraries/{libraryid}/labrequeues', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LabRequeue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_librarypools_id(self, id, **kwargs):  # noqa: E501
        """Update a pool  # noqa: E501

        The status of a pool may be updated to the following values: Active, Failed, Consumed or QCFailed. Setting a pool to Failed or QCFailed will exclude all FASTQ datasets created from the pool from app launch when one of its biosamples are selected as an input. This is also reflected on the Actual Yield of each biosample in the pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_librarypools_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostLibraryPoolIdRequest body:
        :return: V1pre3LibraryPoolCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_librarypools_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_librarypools_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_librarypools_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a pool  # noqa: E501

        The status of a pool may be updated to the following values: Active, Failed, Consumed or QCFailed. Setting a pool to Failed or QCFailed will exclude all FASTQ datasets created from the pool from app launch when one of its biosamples are selected as an input. This is also reflected on the Actual Yield of each biosample in the pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_librarypools_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostLibraryPoolIdRequest body:
        :return: V1pre3LibraryPoolCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_librarypools_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_librarypools_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/librarypools/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3LibraryPoolCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_librarypools_poolid_labrequeues(self, poolid, **kwargs):  # noqa: E501
        """Add a lab requeue request for more yield from a pool  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_librarypools_poolid_labrequeues(poolid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str poolid: (required)
        :param V2CreateExistingPoolLabRequeueRequest body:
        :return: V2LabRequeue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_librarypools_poolid_labrequeues_with_http_info(poolid, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_librarypools_poolid_labrequeues_with_http_info(poolid, **kwargs)  # noqa: E501
            return data

    def post_v2_librarypools_poolid_labrequeues_with_http_info(self, poolid, **kwargs):  # noqa: E501
        """Add a lab requeue request for more yield from a pool  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_librarypools_poolid_labrequeues_with_http_info(poolid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str poolid: (required)
        :param V2CreateExistingPoolLabRequeueRequest body:
        :return: V2LabRequeue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['poolid', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_librarypools_poolid_labrequeues" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'poolid' is set
        if ('poolid' not in params or
                params['poolid'] is None):
            raise ValueError("Missing the required parameter `poolid` when calling `post_v2_librarypools_poolid_labrequeues`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'poolid' in params:
            path_params['poolid'] = params['poolid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/librarypools/{poolid}/labrequeues', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LabRequeue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_oauthv1_tokenfromoauthv2(self, **kwargs):  # noqa: E501
        """post_v2_oauthv1_tokenfromoauthv2  # noqa: E501

        Get OAuthV1 token using an OAuthV2Token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_oauthv1_tokenfromoauthv2(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2OAuthV1FromOAuthV2Request body:
        :return: V2OAuthV1Token
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_oauthv1_tokenfromoauthv2_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_oauthv1_tokenfromoauthv2_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_oauthv1_tokenfromoauthv2_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_oauthv1_tokenfromoauthv2  # noqa: E501

        Get OAuthV1 token using an OAuthV2Token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_oauthv1_tokenfromoauthv2_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2OAuthV1FromOAuthV2Request body:
        :return: V2OAuthV1Token
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_oauthv1_tokenfromoauthv2" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/oauthv1/tokenfromoauthv2', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2OAuthV1Token',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_oauthv2_token(self, **kwargs):  # noqa: E501
        """post_v2_oauthv2_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_oauthv2_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OAuthV2AccessTokenRequest body:
        :return: OAuthV2AccessTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_oauthv2_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_oauthv2_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_oauthv2_token_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_oauthv2_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_oauthv2_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OAuthV2AccessTokenRequest body:
        :return: OAuthV2AccessTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_oauthv2_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/oauthv2/token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OAuthV2AccessTokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_oauthv2_tokenfromapplicationjwt(self, **kwargs):  # noqa: E501
        """post_v2_oauthv2_tokenfromapplicationjwt  # noqa: E501

        Create token for a trusted Platform service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_oauthv2_tokenfromapplicationjwt(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2OAuthV2TokenFromApplicationJwtRequest body:
        :return: V2OAuthV2Token
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_oauthv2_tokenfromapplicationjwt_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_oauthv2_tokenfromapplicationjwt_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_oauthv2_tokenfromapplicationjwt_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_oauthv2_tokenfromapplicationjwt  # noqa: E501

        Create token for a trusted Platform service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_oauthv2_tokenfromapplicationjwt_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2OAuthV2TokenFromApplicationJwtRequest body:
        :return: V2OAuthV2Token
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_oauthv2_tokenfromapplicationjwt" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/oauthv2/tokenfromapplicationjwt', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2OAuthV2Token',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_oauthv2tokens_userid(self, userid, **kwargs):  # noqa: E501
        """post_v2_oauthv2tokens_userid  # noqa: E501

        Create token for a given user id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_oauthv2tokens_userid(userid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str userid: (required)
        :param V2OAuthV2TokenRequest body:
        :return: V2OAuthV2Token
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_oauthv2tokens_userid_with_http_info(userid, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_oauthv2tokens_userid_with_http_info(userid, **kwargs)  # noqa: E501
            return data

    def post_v2_oauthv2tokens_userid_with_http_info(self, userid, **kwargs):  # noqa: E501
        """post_v2_oauthv2tokens_userid  # noqa: E501

        Create token for a given user id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_oauthv2tokens_userid_with_http_info(userid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str userid: (required)
        :param V2OAuthV2TokenRequest body:
        :return: V2OAuthV2Token
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['userid', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_oauthv2tokens_userid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'userid' is set
        if ('userid' not in params or
                params['userid'] is None):
            raise ValueError("Missing the required parameter `userid` when calling `post_v2_oauthv2tokens_userid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'userid' in params:
            path_params['userid'] = params['userid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/oauthv2tokens/{userid}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2OAuthV2Token',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_preprequests_preprequestid_labrequeues(self, preprequestid, **kwargs):  # noqa: E501
        """Add a lab requeue request for more yield from a biosample  # noqa: E501

        Request a requeue for a new library, given an existing preprequest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_preprequests_preprequestid_labrequeues(preprequestid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preprequestid: (required)
        :param V2CreateNewLibraryLabRequeueRequest body:
        :return: V2LabRequeue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_preprequests_preprequestid_labrequeues_with_http_info(preprequestid, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_preprequests_preprequestid_labrequeues_with_http_info(preprequestid, **kwargs)  # noqa: E501
            return data

    def post_v2_preprequests_preprequestid_labrequeues_with_http_info(self, preprequestid, **kwargs):  # noqa: E501
        """Add a lab requeue request for more yield from a biosample  # noqa: E501

        Request a requeue for a new library, given an existing preprequest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_preprequests_preprequestid_labrequeues_with_http_info(preprequestid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str preprequestid: (required)
        :param V2CreateNewLibraryLabRequeueRequest body:
        :return: V2LabRequeue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['preprequestid', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_preprequests_preprequestid_labrequeues" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'preprequestid' is set
        if ('preprequestid' not in params or
                params['preprequestid'] is None):
            raise ValueError("Missing the required parameter `preprequestid` when calling `post_v2_preprequests_preprequestid_labrequeues`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'preprequestid' in params:
            path_params['preprequestid'] = params['preprequestid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/preprequests/{preprequestid}/labrequeues', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2LabRequeue',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_projects(self, name, **kwargs):  # noqa: E501
        """Create a project by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_projects(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of the project. (required)
        :param V2PostProjectsRequest body:
        :param str description: Optional description of the project.
        :return: V1pre3Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_projects_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_projects_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def post_v2_projects_with_http_info(self, name, **kwargs):  # noqa: E501
        """Create a project by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_projects_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of the project. (required)
        :param V2PostProjectsRequest body:
        :param str description: Optional description of the project.
        :return: V1pre3Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'body', 'description']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_projects" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_v2_projects`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_projects_id_datasets(self, id, **kwargs):  # noqa: E501
        """Create a dataset within a specific project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_projects_id_datasets(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Project ID (required)
        :param V2PostProjectsIdDatasetsRequest body:
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_projects_id_datasets_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_projects_id_datasets_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_projects_id_datasets_with_http_info(self, id, **kwargs):  # noqa: E501
        """Create a dataset within a specific project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_projects_id_datasets_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Project ID (required)
        :param V2PostProjectsIdDatasetsRequest body:
        :return: V2Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_projects_id_datasets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_projects_id_datasets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{id}/datasets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Dataset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_publishappsessionstatus(self, **kwargs):  # noqa: E501
        """post_v2_publishappsessionstatus  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_publishappsessionstatus(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostPublishAppSessionStatusRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_publishappsessionstatus_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_publishappsessionstatus_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_publishappsessionstatus_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_publishappsessionstatus  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_publishappsessionstatus_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostPublishAppSessionStatusRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_publishappsessionstatus" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/publishappsessionstatus', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_restore(self, **kwargs):  # noqa: E501
        """Bulk restore.  # noqa: E501

        Restore one or more Runs or Projects.  The process is async, and may take up to 48 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_restore(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BulkRestoreRequest body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_restore_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_restore_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_restore_with_http_info(self, **kwargs):  # noqa: E501
        """Bulk restore.  # noqa: E501

        Restore one or more Runs or Projects.  The process is async, and may take up to 48 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_restore_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BulkRestoreRequest body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_restore" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/restore', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_runs(self, experimentname, instrumenttype, **kwargs):  # noqa: E501
        """Create a new run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs(experimentname, instrumenttype, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str experimentname: The name of the experiment. (required)
        :param str instrumenttype: The InstrumentType identifies from which the run is generated. This is REQUIRED for runs uploaded manually. Runs uploaded from an instrument must specify the ClientKey. AllowedValues: 'HiSeq1000', 'HiSeq1500', 'HiSeq2000', 'HiSeq2500', 'HiSeq3000', 'HiSeq4000', 'HiSeqX', 'NovaSeq5000', 'NovaSeq6000', 'MiniSeq', 'MiSeq', 'MiSeqDx', 'NextSeq', 'NextSeqDx', 'iSeq100' (required)
        :param V2PostRunsRequest body:
        :param str samplesheetname: The name of the sample sheet.
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_runs_with_http_info(experimentname, instrumenttype, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_runs_with_http_info(experimentname, instrumenttype, **kwargs)  # noqa: E501
            return data

    def post_v2_runs_with_http_info(self, experimentname, instrumenttype, **kwargs):  # noqa: E501
        """Create a new run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_with_http_info(experimentname, instrumenttype, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str experimentname: The name of the experiment. (required)
        :param str instrumenttype: The InstrumentType identifies from which the run is generated. This is REQUIRED for runs uploaded manually. Runs uploaded from an instrument must specify the ClientKey. AllowedValues: 'HiSeq1000', 'HiSeq1500', 'HiSeq2000', 'HiSeq2500', 'HiSeq3000', 'HiSeq4000', 'HiSeqX', 'NovaSeq5000', 'NovaSeq6000', 'MiniSeq', 'MiSeq', 'MiSeqDx', 'NextSeq', 'NextSeqDx', 'iSeq100' (required)
        :param V2PostRunsRequest body:
        :param str samplesheetname: The name of the sample sheet.
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['experimentname', 'instrumenttype', 'body', 'samplesheetname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_runs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'experimentname' is set
        if ('experimentname' not in params or
                params['experimentname'] is None):
            raise ValueError("Missing the required parameter `experimentname` when calling `post_v2_runs`")  # noqa: E501
        # verify the required parameter 'instrumenttype' is set
        if ('instrumenttype' not in params or
                params['instrumenttype'] is None):
            raise ValueError("Missing the required parameter `instrumenttype` when calling `post_v2_runs`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'experimentname' in params:
            query_params.append(('experimentname', params['experimentname']))  # noqa: E501
        if 'instrumenttype' in params:
            query_params.append(('instrumenttype', params['instrumenttype']))  # noqa: E501
        if 'samplesheetname' in params:
            query_params.append(('samplesheetname', params['samplesheetname']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_runs_id(self, id, **kwargs):  # noqa: E501
        """Update an existing run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostRunIdRequest body:
        :param str uploadstatus: Specifies the updated state of a run. AllowedValues: 'Uploading', 'Completed', 'Failed'.
        :param str instrumentrunstatus: Specifies the updated state of a run. AllowedValues: 'Running', 'Stopped', 'InstrumentCompleted', 'Failed', 'Rehybing'.
        :param str runparametersxml: Update the run data based on the contents of run parameters.
        :param str instrumentrunid: Specifies the InstrumentRunId.
        :param int instrumentrunnumber: Specifies the InstrumentRunNumber.
        :param str flowcellbarcode: Specifies the FlowcellBarcode.
        :param str prepkitname: Specifies the PrepkitName.
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_runs_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_runs_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_runs_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an existing run  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostRunIdRequest body:
        :param str uploadstatus: Specifies the updated state of a run. AllowedValues: 'Uploading', 'Completed', 'Failed'.
        :param str instrumentrunstatus: Specifies the updated state of a run. AllowedValues: 'Running', 'Stopped', 'InstrumentCompleted', 'Failed', 'Rehybing'.
        :param str runparametersxml: Update the run data based on the contents of run parameters.
        :param str instrumentrunid: Specifies the InstrumentRunId.
        :param int instrumentrunnumber: Specifies the InstrumentRunNumber.
        :param str flowcellbarcode: Specifies the FlowcellBarcode.
        :param str prepkitname: Specifies the PrepkitName.
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'uploadstatus', 'instrumentrunstatus', 'runparametersxml', 'instrumentrunid', 'instrumentrunnumber', 'flowcellbarcode', 'prepkitname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_runs_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_runs_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'uploadstatus' in params:
            query_params.append(('uploadstatus', params['uploadstatus']))  # noqa: E501
        if 'instrumentrunstatus' in params:
            query_params.append(('instrumentrunstatus', params['instrumentrunstatus']))  # noqa: E501
        if 'runparametersxml' in params:
            query_params.append(('runparametersxml', params['runparametersxml']))  # noqa: E501
        if 'instrumentrunid' in params:
            query_params.append(('instrumentrunid', params['instrumentrunid']))  # noqa: E501
        if 'instrumentrunnumber' in params:
            query_params.append(('instrumentrunnumber', params['instrumentrunnumber']))  # noqa: E501
        if 'flowcellbarcode' in params:
            query_params.append(('flowcellbarcode', params['flowcellbarcode']))  # noqa: E501
        if 'prepkitname' in params:
            query_params.append(('prepkitname', params['prepkitname']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_runs_id_file_upload_info(self, id, **kwargs):  # noqa: E501
        """post_v2_runs_id_file_upload_info  # noqa: E501

        Complete multipart upload and report uploaded files to a resource (sample or run)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_id_file_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2ResourcePresignedUrlCompleteRequest body:
        :return: V1pre3FileCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_runs_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_runs_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_runs_id_file_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """post_v2_runs_id_file_upload_info  # noqa: E501

        Complete multipart upload and report uploaded files to a resource (sample or run)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_id_file_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2ResourcePresignedUrlCompleteRequest body:
        :return: V1pre3FileCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_runs_id_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_runs_id_file_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/file-upload-info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3FileCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_runs_id_files(self, file, id, **kwargs):  # noqa: E501
        """post_v2_runs_id_files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_id_files(file, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str id: The Id of the resource (required)
        :return: V1pre3File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_runs_id_files_with_http_info(file, id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_runs_id_files_with_http_info(file, id, **kwargs)  # noqa: E501
            return data

    def post_v2_runs_id_files_with_http_info(self, file, id, **kwargs):  # noqa: E501
        """post_v2_runs_id_files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_id_files_with_http_info(file, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str id: The Id of the resource (required)
        :return: V1pre3File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_runs_id_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `post_v2_runs_id_files`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_runs_id_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/{id}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3File',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_runs_start(self, **kwargs):  # noqa: E501
        """Create a new run using GSS  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_start(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostRunsStartRequest body:
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_runs_start_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_runs_start_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_runs_start_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new run using GSS  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_runs_start_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostRunsStartRequest body:
        :return: V2Run
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_runs_start" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/runs/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Run',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_samples_id_file_upload_info(self, id, **kwargs):  # noqa: E501
        """post_v2_samples_id_file_upload_info  # noqa: E501

        Complete multipart upload and report uploaded files to a resource (sample or run)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_samples_id_file_upload_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2ResourcePresignedUrlCompleteRequest body:
        :return: V1pre3FileCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_samples_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_samples_id_file_upload_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_samples_id_file_upload_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """post_v2_samples_id_file_upload_info  # noqa: E501

        Complete multipart upload and report uploaded files to a resource (sample or run)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_samples_id_file_upload_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2ResourcePresignedUrlCompleteRequest body:
        :return: V1pre3FileCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_samples_id_file_upload_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_samples_id_file_upload_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/samples/{id}/file-upload-info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3FileCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_tokens_instruments(self, **kwargs):  # noqa: E501
        """Creates a Platform JWT token for an instrument  # noqa: E501

        Creates a Platform JWT for an instrument.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_tokens_instruments(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2CreateInstrumentJwtRequest body:
        :return: V2InstrumentJwt
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_tokens_instruments_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_tokens_instruments_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_tokens_instruments_with_http_info(self, **kwargs):  # noqa: E501
        """Creates a Platform JWT token for an instrument  # noqa: E501

        Creates a Platform JWT for an instrument.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_tokens_instruments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2CreateInstrumentJwtRequest body:
        :return: V2InstrumentJwt
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_tokens_instruments" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/tokens/instruments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2InstrumentJwt',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_trash_id_restorefromtrash(self, id, **kwargs):  # noqa: E501
        """Restore an item from the trash back to its active state  # noqa: E501

        The ID used in this endpoint is the ID given to the item when it is put in the trash, not the original ID from the resource, i.e. its project ID. Please use the GET /v2/trash endpoint to find the items trash ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_trash_id_restorefromtrash(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V1pre3PostTrashItemRestoreFromTrashRequest body:
        :return: V1pre3TrashItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_trash_id_restorefromtrash_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_trash_id_restorefromtrash_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_trash_id_restorefromtrash_with_http_info(self, id, **kwargs):  # noqa: E501
        """Restore an item from the trash back to its active state  # noqa: E501

        The ID used in this endpoint is the ID given to the item when it is put in the trash, not the original ID from the resource, i.e. its project ID. Please use the GET /v2/trash endpoint to find the items trash ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_trash_id_restorefromtrash_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V1pre3PostTrashItemRestoreFromTrashRequest body:
        :return: V1pre3TrashItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_trash_id_restorefromtrash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_trash_id_restorefromtrash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/trash/{id}/restorefromtrash', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V1pre3TrashItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_unzip(self, **kwargs):  # noqa: E501
        """Bulk Unzip.  # noqa: E501

        Unzip one or more Runs. The status will update right away, but the unzip process itself is async  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_unzip(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BulkUnzipRequest body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_unzip_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_unzip_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_unzip_with_http_info(self, **kwargs):  # noqa: E501
        """Bulk Unzip.  # noqa: E501

        Unzip one or more Runs. The status will update right away, but the unzip process itself is async  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_unzip_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2BulkUnzipRequest body:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_unzip" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/unzip', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_useraccounttransfer(self, **kwargs):  # noqa: E501
        """User account transfer. Requires Administrator role  # noqa: E501

        Intitiates a User account transfer. API only kicks off the process which itself is async.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_useraccounttransfer(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2UserAccountTransferRequest body:
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_useraccounttransfer_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_useraccounttransfer_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_useraccounttransfer_with_http_info(self, **kwargs):  # noqa: E501
        """User account transfer. Requires Administrator role  # noqa: E501

        Intitiates a User account transfer. API only kicks off the process which itself is async.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_useraccounttransfer_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2UserAccountTransferRequest body:
        :return: V2AppSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_useraccounttransfer" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/useraccounttransfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AppSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_useragreements(self, **kwargs):  # noqa: E501
        """post_v2_useragreements  # noqa: E501

        Sign an agreement.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_useragreements(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2SignAgreementRequest body:
        :return: V2UserAgreementCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_useragreements_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_useragreements_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_useragreements_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_useragreements  # noqa: E501

        Sign an agreement.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_useragreements_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2SignAgreementRequest body:
        :return: V2UserAgreementCompact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_useragreements" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/useragreements/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2UserAgreementCompact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_users_current(self, **kwargs):  # noqa: E501
        """post_v2_users_current  # noqa: E501

        Change current user context.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_current(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostUsersCurrentRequest body:
        :return: V2User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_users_current_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_users_current_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_users_current_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_users_current  # noqa: E501

        Change current user context.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_current_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostUsersCurrentRequest body:
        :return: V2User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_users_current" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_users_files(self, **kwargs):  # noqa: E501
        """Upload a file to the user's volume in GDS  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_files(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2GdsFileUploadRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_users_files_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_users_files_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_users_files_with_http_info(self, **kwargs):  # noqa: E501
        """Upload a file to the user's volume in GDS  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_files_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2GdsFileUploadRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_users_files" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_users_id_settings(self, id, **kwargs):  # noqa: E501
        """Update the user's settings   # noqa: E501

        A user may have settings such as how they receive notifications and expiration time on lab requeues. This currently only works with a session cookie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_id_settings(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostUserSettingsRequest body:
        :return: V2UserSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_users_id_settings_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_users_id_settings_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_users_id_settings_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update the user's settings   # noqa: E501

        A user may have settings such as how they receive notifications and expiration time on lab requeues. This currently only works with a session cookie.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_id_settings_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostUserSettingsRequest body:
        :return: V2UserSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_users_id_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_users_id_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}/settings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2UserSettingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_users_id_v2analysisconfigtemplate(self, id, **kwargs):  # noqa: E501
        """Change Analysis Configuration Template Feature Enabled for calling user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_id_v2analysisconfigtemplate(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostUsersIdAnalysisConfigTemplateRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_users_id_v2analysisconfigtemplate_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_users_id_v2analysisconfigtemplate_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_users_id_v2analysisconfigtemplate_with_http_info(self, id, **kwargs):  # noqa: E501
        """Change Analysis Configuration Template Feature Enabled for calling user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_id_v2analysisconfigtemplate_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostUsersIdAnalysisConfigTemplateRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_users_id_v2analysisconfigtemplate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_users_id_v2analysisconfigtemplate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}analysisconfigtemplate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_users_id_v2biosampleregistry(self, id, **kwargs):  # noqa: E501
        """Change V2 BioSample Registry Enabled for calling user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_id_v2biosampleregistry(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostUsersIdV2BioSampleRegistryRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_users_id_v2biosampleregistry_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_users_id_v2biosampleregistry_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def post_v2_users_id_v2biosampleregistry_with_http_info(self, id, **kwargs):  # noqa: E501
        """Change V2 BioSample Registry Enabled for calling user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_users_id_v2biosampleregistry_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param V2PostUsersIdV2BioSampleRegistryRequest body:
        :return: V2Error
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_users_id_v2biosampleregistry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `post_v2_users_id_v2biosampleregistry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{id}biosampleregistry', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_v2_validatesignedurl(self, **kwargs):  # noqa: E501
        """post_v2_validatesignedurl  # noqa: E501

        Validate a OAuthV1 signed url for GroundControl  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_validatesignedurl(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostSignedUrlValidationRequest body:
        :return: V2SignedUrlValidation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_v2_validatesignedurl_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_v2_validatesignedurl_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_v2_validatesignedurl_with_http_info(self, **kwargs):  # noqa: E501
        """post_v2_validatesignedurl  # noqa: E501

        Validate a OAuthV1 signed url for GroundControl  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_v2_validatesignedurl_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2PostSignedUrlValidationRequest body:
        :return: V2SignedUrlValidation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_v2_validatesignedurl" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/validatesignedurl', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2SignedUrlValidation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_v2_applications_id_qcthresholds(self, id, **kwargs):  # noqa: E501
        """Add or update the QC thresholds applied to an analysis workflow  # noqa: E501

        List the QC thresholds to be updated. You must include the name of the metric to be thresholded, the type of logical operator, the dataset type unique ID to apply the threshold to, and the threshold values.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_v2_applications_id_qcthresholds(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param list[V2QcThreshold] qcthresholds:
        :return: V2QcThresholdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_v2_applications_id_qcthresholds_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_v2_applications_id_qcthresholds_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def put_v2_applications_id_qcthresholds_with_http_info(self, id, **kwargs):  # noqa: E501
        """Add or update the QC thresholds applied to an analysis workflow  # noqa: E501

        List the QC thresholds to be updated. You must include the name of the metric to be thresholded, the type of logical operator, the dataset type unique ID to apply the threshold to, and the threshold values.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_v2_applications_id_qcthresholds_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param list[V2QcThreshold] qcthresholds:
        :return: V2QcThresholdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'qcthresholds']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_v2_applications_id_qcthresholds" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_v2_applications_id_qcthresholds`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'qcthresholds' in params:
            query_params.append(('qcthresholds', params['qcthresholds']))  # noqa: E501
            collection_formats['qcthresholds'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}/qcthresholds', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2QcThresholdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_v2_applications_id_workflowdependencies(self, id, **kwargs):  # noqa: E501
        """Add or update the workflow dependencies of an analysis workflow  # noqa: E501

        Add the required triggers for the analysis workflow to launch. Workflows can depend on a certain amount of biosample actual yield to show up or they can depend on another app completing.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_v2_applications_id_workflowdependencies(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str version:
        :param list[V2AnalysisWorkflowDependency] dependencies:
        :return: V2AnalysisWorkflowDependenciesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_v2_applications_id_workflowdependencies_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_v2_applications_id_workflowdependencies_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def put_v2_applications_id_workflowdependencies_with_http_info(self, id, **kwargs):  # noqa: E501
        """Add or update the workflow dependencies of an analysis workflow  # noqa: E501

        Add the required triggers for the analysis workflow to launch. Workflows can depend on a certain amount of biosample actual yield to show up or they can depend on another app completing.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_v2_applications_id_workflowdependencies_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Id of the resource (required)
        :param str version:
        :param list[V2AnalysisWorkflowDependency] dependencies:
        :return: V2AnalysisWorkflowDependenciesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'version', 'dependencies']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_v2_applications_id_workflowdependencies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `put_v2_applications_id_workflowdependencies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'dependencies' in params:
            query_params.append(('dependencies', params['dependencies']))  # noqa: E501
            collection_formats['dependencies'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/applications/{id}/workflowdependencies', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2AnalysisWorkflowDependenciesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_v2_laneqcthresholds(self, **kwargs):  # noqa: E501
        """Add or update the QC thresholds applied to lanes  # noqa: E501

        List the QC thresholds to be updated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_v2_laneqcthresholds(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[V2QcThreshold] qcthresholds:
        :param str id: The Id of the resource
        :return: V2QcThresholdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_v2_laneqcthresholds_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.put_v2_laneqcthresholds_with_http_info(**kwargs)  # noqa: E501
            return data

    def put_v2_laneqcthresholds_with_http_info(self, **kwargs):  # noqa: E501
        """Add or update the QC thresholds applied to lanes  # noqa: E501

        List the QC thresholds to be updated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_v2_laneqcthresholds_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[V2QcThreshold] qcthresholds:
        :param str id: The Id of the resource
        :return: V2QcThresholdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['qcthresholds', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_v2_laneqcthresholds" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'qcthresholds' in params:
            query_params.append(('qcthresholds', params['qcthresholds']))  # noqa: E501
            collection_formats['qcthresholds'] = 'csv'  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/laneqcthresholds', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='V2QcThresholdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_v2_notifications_dismiss(self, stream, type, **kwargs):  # noqa: E501
        """Dismiss a user notification.  # noqa: E501

        Dismiss a user notification. Only DataDeletion, Storage or Subscription notifications can dismissed. For Deleting an Activity notification, use the DELETE endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_v2_notifications_dismiss(stream, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stream: The stream type of the notification to be dismissed.Only DataDeletion, Storage or Subscription notifications can dismissed.   (required)
        :param str type: The Type of the notification with in a stream.Only notifications with 'IsDismissable' flag set are dismissable (required)
        :param str id: The Id of the resource
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_v2_notifications_dismiss_with_http_info(stream, type, **kwargs)  # noqa: E501
        else:
            (data) = self.put_v2_notifications_dismiss_with_http_info(stream, type, **kwargs)  # noqa: E501
            return data

    def put_v2_notifications_dismiss_with_http_info(self, stream, type, **kwargs):  # noqa: E501
        """Dismiss a user notification.  # noqa: E501

        Dismiss a user notification. Only DataDeletion, Storage or Subscription notifications can dismissed. For Deleting an Activity notification, use the DELETE endpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_v2_notifications_dismiss_with_http_info(stream, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stream: The stream type of the notification to be dismissed.Only DataDeletion, Storage or Subscription notifications can dismissed.   (required)
        :param str type: The Type of the notification with in a stream.Only notifications with 'IsDismissable' flag set are dismissable (required)
        :param str id: The Id of the resource
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stream', 'type', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_v2_notifications_dismiss" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'stream' is set
        if ('stream' not in params or
                params['stream'] is None):
            raise ValueError("Missing the required parameter `stream` when calling `put_v2_notifications_dismiss`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `put_v2_notifications_dismiss`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stream' in params:
            query_params.append(('stream', params['stream']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basespace_auth']  # noqa: E501

        return self.api_client.call_api(
            '/notifications/dismiss', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
